{"title":"前后端常见网络安全问题及防范措施","id":"d127138063d45832d5b7","mtime":1649217070788,"ctime":1649216955938,"issues":{"number":33,"commentsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/33/comments","reactionsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/33/reactions"},"head":null,"foot":null,"dirs":[{"leave":2,"title":"XSS（跨站脚本攻击）","children":[{"leave":3,"title":"存储型 XSS","children":[{"leave":4,"title":"存储型防护","children":[]}]},{"leave":3,"title":"反射型 XSS","children":[]},{"leave":3,"title":"DOM 型 XSS","children":[{"leave":4,"title":"DOM 型防护","children":[]}]},{"leave":3,"title":"CSP 策略","children":[]}]},{"leave":2,"title":"CSRF（跨站请求伪造）","children":[{"leave":3,"title":"阻止外域访问","children":[]},{"leave":3,"title":"阻止外域访问携带cookie","children":[]},{"leave":3,"title":"双重 cookie","children":[]},{"leave":3,"title":"使用 token","children":[]},{"leave":3,"title":"二次确认","children":[]}]},{"leave":2,"title":"中间人攻击","children":[{"leave":3,"title":"相关词汇","children":[]},{"leave":3,"title":"`https`通讯的过程","children":[]}]},{"leave":2,"title":"相关阅读","children":[]}],"body":"<p>网络安全是用于保护关键系统和敏感信息免遭数字攻击的实践。本文例举了常见的网络安全问题及在前后端防范的方法。</p>\n<h2 id=\"xss（跨站脚本攻击）\">XSS（跨站脚本攻击）</h2>\n<p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称<code>XSS</code>，是一种代码注入攻击。攻击者通过在目标网站上注入脚本，让它运行在用户浏览器上，利用这些脚本可以获取用户的信息例如<code>cookie</code>。<code>XSS</code>的本质就是恶意代码没有经过处理，跟网站正常代码混在一起。下面说说常见的<code>XSS</code>类别以及如何防护。</p>\n<h3 id=\"存储型-xss\">存储型 XSS</h3>\n<p>存储型是指攻击者将恶意代码提交到服务器的数据库中，当普通用户正常打开网站浏览时，服务器从数据库中取出并拼接到<code>HTML</code>中返回给浏览器，这时就加载到了恶意代码。这类攻击主要是由于未转译用户保存数据而直接显示引起的。</p>\n<p>用户提交信息</p>\n<pre><code class=\"language-text\">&lt;img src=\"xxx\" onerror=\"alert('XSS Attack')\">\n</code></pre>\n<p>服务端使用模板</p>\n<pre><code class=\"language-ejs\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>comment<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token ejs language-ejs\"><span class=\"token delimiter punctuation\">&lt;%=</span><span class=\"token language-javascript\"> comment<span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span> </span><span class=\"token delimiter punctuation\">%></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>或前端使用数据</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> $comment <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#comment\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n$comment<span class=\"token punctuation\">.</span><span class=\"token property-access\">innerHTML</span> <span class=\"token operator\">=</span> comment<span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"存储型防护\">存储型防护</h4>\n<p>首先我们需要明确是否需要 html 片段，如果可能的话将他们当做文本来使用。比如在模板中使用<code>&lt;%-</code>而不是<code>&lt;%=</code> <em>(示例说明，上方是 ejs，根据不同模板而定)</em> ；在客户端中尽可能使用<code>textContent</code>而不是<code>innerHTML</code>。</p>\n<p>如果确实需要 html 片段来显示则需要特别注意，因为富文本是最容易受到攻击的。我们可以为这个富文本建立一个白名单，滤出允许出现的标签和属性然后再使用它。可以借助<code>xss</code>库来完成这件事、</p>\n<blockquote>\n<p>注意：在 HTML5 之后，innerHTML 不会执行 script 脚本。</p>\n</blockquote>\n<pre><code class=\"language-shell\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> xss\n</code></pre>\n<pre><code class=\"language-js\"><span class=\"token keyword module\">import</span> <span class=\"token imports\">filterXSS</span> <span class=\"token keyword module\">from</span> <span class=\"token string\">\"xss\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">whiteList</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">span</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">p</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">div</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">h1</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">h2</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">h3</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">img</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'alt'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'src'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'title'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'href'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 过滤所有非白名单的标签保留内容</span>\n  <span class=\"token literal-property property\">stripIgnoreTag</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token comment\">// 过滤script标签并丢弃内容</span>\n  <span class=\"token literal-property property\">stripIgnoreTagBody</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"script\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 客户端处理</span>\n$comment<span class=\"token punctuation\">.</span><span class=\"token property-access\">innerHTML</span> <span class=\"token operator\">=</span> <span class=\"token function\">filterXSS</span><span class=\"token punctuation\">(</span>comment<span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span><span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 服务端处理</span>\nejs<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">renderFile</span><span class=\"token punctuation\">(</span>\n  filename<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token spread operator\">...</span>comment<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">body</span><span class=\"token operator\">:</span> <span class=\"token function\">filterXSS</span><span class=\"token punctuation\">(</span>comment<span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> str</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword control-flow\">else</span> <span class=\"token punctuation\">{</span>\n      res<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token string-property property\">'Content-Type'</span><span class=\"token operator\">:</span> <span class=\"token string\">'text/html'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      res<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      res<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3 id=\"反射型-xss\">反射型 XSS</h3>\n<p>反射型是指攻击者创建出特出的<code>URL</code>，而开发人员未对<code>URL</code>进行处理，直接将<code>URL</code>参数进行拼接<code>HTML</code>使用，当用户打开这个<code>URL</code>时就加载到了恶意代码。这类攻击主要是由于未转译<code>URL</code>数据而直接使用引起的。</p>\n<p>用户提交信息</p>\n<pre><code class=\"language-text\">&lt;img src=\"xxx\" onerror=\"alert('XSS Attack')\">\n</code></pre>\n<p>服务端使用模板</p>\n<pre><code class=\"language-ejs\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">placeholder</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>搜索<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>search<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>result<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span>\n    搜索关键词：\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>keyword<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token ejs language-ejs\"><span class=\"token delimiter punctuation\">&lt;%=</span><span class=\"token language-javascript\"> <span class=\"token function\">getParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"keyword\"</span><span class=\"token punctuation\">)</span> </span><span class=\"token delimiter punctuation\">%></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>或客户端使用数据</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> params <span class=\"token operator\">=</span> <span class=\"token known-class-name class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">fromEntries</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">URLSearchParams</span><span class=\"token punctuation\">(</span><span class=\"token dom variable\">location</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">search</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> $keyword <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#keyword\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n$search<span class=\"token punctuation\">.</span><span class=\"token property-access\">innerHTML</span> <span class=\"token operator\">=</span> params<span class=\"token punctuation\">.</span><span class=\"token property-access\">keyword</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这里处理方式与存储型一样不在赘述。</p>\n<h3 id=\"dom-型-xss\">DOM 型 XSS</h3>\n<p><code>DOM</code>型是指前端<code>JavaScript</code>代码不严谨，将数据直接设置为<code>DOM</code>属性，而有些属性字符串是能作为代码运行。比如比较常见的就是<code>a</code>标签的<code>href</code>属性，还有一些内联事件处理器如<code>onload</code>、<code>onerror</code>、<code>onclick</code>等等。</p>\n<p>用户提交信息</p>\n<pre><code class=\"language-text\">javascript:alert(&#39;XSS Attack&#39;)\n</code></pre>\n<p>客户端使用数据</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> $recom <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">querySelect</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a#recom\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n$recom<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"href\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span><span class=\"token property-access\">recom</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"dom-型防护\">DOM 型防护</h4>\n<p>这类攻击我们需要将属性转译，或者忽略掉恶意代码，可以通过检测是否是正确资源链接，如果不是则删除。为了防止漏掉某项，还是建议找第三方成熟库来做这件事，比如我们可以通过<code>xss</code>库的内置方法<code>safeAttrValue</code>来做这件事。</p>\n<pre><code class=\"language-js\"><span class=\"token keyword module\">import</span> <span class=\"token imports\">filterXSS</span> <span class=\"token keyword module\">from</span> <span class=\"token string\">\"xss\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> link <span class=\"token operator\">=</span> filterXSS<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">safeAttrValue</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"href\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span><span class=\"token property-access\">recom</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n$recom<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"href\"</span><span class=\"token punctuation\">,</span> link<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3 id=\"csp-策略\">CSP 策略</h3>\n<p>&quot;网页安全政策&quot;（Content Security Policy，缩写 CSP）是厂商们推出的防护<code>XSS</code>的策略。本质上就是白名单制度，告诉浏览器哪些资源可加载，可执行，不过这个白名单的实现和执行是在浏览器完成的。我们只需要在<code>http</code>响应头中配置<code>Content-Security-Policy</code>字段，在这个字段中配置。</p>\n<p>关于具体配置项和如何使用可参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy\">mozilla</a>和<a href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\">阮一峰的博文</a></p>\n<h2 id=\"csrf（跨站请求伪造）\">CSRF（跨站请求伪造）</h2>\n<p><code>Cross-site request forgery</code>（跨站请求伪造）简称<code>CSRF</code>，是一种利用用户凭证，进而伪装成用户执行非本意的操作的攻击方法。典型的<code>CSRF</code>攻击就是用户登录了 A 网站，然后打开了 B 网站，B 网站往 A 网站发送请求，由于 A 网站未做防护，接受了这个请求通过凭证认证用户并处理。</p>\n<p><code>CSRF</code>有攻击在第三方网站执行，攻击利用用户的凭证数据，无法直接窃取凭证而是伪装等特点。我们可以针对这个特点指定防护。</p>\n<h3 id=\"阻止外域访问\">阻止外域访问</h3>\n<p>既然<code>CSRF</code>是来自第三方网站的，那我们在在请求中拦截不安全域名不是就可以了。在<code>http</code>协议中可以使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin\">origin</a>和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer\">referer</a>请求头可以获取请求来源域名。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>origin</th>\n<th>referer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>描述</td>\n<td>指示了请求来自于哪个站点</td>\n<td>当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面（如搜索引擎）里的链接进入的</td>\n</tr>\n<tr>\n<td>携带值</td>\n<td>服务器名称，并不包含任何路径信息。</td>\n<td>服务器名称，并不包含任何路径信息。</td>\n</tr>\n<tr>\n<td>发送</td>\n<td><code>CORS</code> <em>（跨域请求）</em> 请求或非<code>GET</code>和<code>HEAD</code>请求。</td>\n<td>非<code>http</code>跳转<code>https</code></td>\n</tr>\n<tr>\n<td>特殊</td>\n<td>由于同源定义不同<code>IE11</code>跨站不会携带；302重定向时也不会携带</td>\n<td>在<code>html</code>中对于资源可以指定是否发送<code>referer</code>，参见<a href=\"http://www.ruanyifeng.com/blog/2019/06/http-referer.html\">阮一峰博文</a></td>\n</tr>\n</tbody></table>\n<p>我们在后端拦截器中可以获取来源，如果是可信地址就放行，不可信来源则档回。 </p>\n<p>但是有些情况我们还是需要特殊处理，如果两个值都获取不到时如果没做二次确认（如下方确认处理）最好拦截认为是不可信的。</p>\n<p>如果不是可信来源全部拦截还会造成一个问题，比如从<code>google</code>一类搜索引擎进入的，<code>referer</code>值就是<code>www.google.com</code>也会被当成<code>CSRF</code>拦截下来，那我们的页面就打不开了，我们需要为<code>GET</code>请求且<code>Accept</code>为<code>text/html</code>一类的请求放行。但是这又造成另一个问题，如果一些接口是通过<code>GET</code>携带参数来实现功能的话，这类接口也防御不了<code>CSRF</code>，<strong>这也是GET为什么安全性比POST弱的其中一个原因。</strong></p>\n<h3 id=\"阻止外域访问携带cookie\">阻止外域访问携带cookie</h3>\n<p>在<code>chrome51</code>之后浏览器对<code>cookie</code>新增了一个会影响跨站访问携带凭证的属性 <strong>SameSite</strong>，下面是这个属性的值：</p>\n<ul>\n<li><code>Strict</code>，严格的，完全禁止第三方<code>cookie</code>，只有当前网页URL与请求目标一致才会携带。可能造成不好的用户体验，比如从一个<code>github</code>连接点击进去不会携带<code>cookie</code>会被判断为未登录</li>\n<li><code>Lax</code>，稍微宽松，大多数不允许第三方<code>cookie</code>，从顶级导航到目标地址的<code>Get</code> <em>（链接，预加载请求，GET表单）</em> 除外。</li>\n<li><code>None</code>允许第三方跨站访问携带<code>cookie</code>，该属性有一个要求，必须同时为<code>cookie</code>设置<code>Secure</code> <em>（该值指明cookie只能在https请求中被携带）</em> ，第三方必须是<code>https</code>协议的源。</li>\n</ul>\n<p>下图是这个属性的兼容性</p>\n<p><img src=\"/article/d127138063d45832d5b7/./img/same-site-caniuse.png\" alt=\"same-site-caniuse.png\"></p>\n<p>将<code>cookie</code>的<code>SameSite</code>设置为<code>Strict</code>就很安全了，任何跨域都不能携带<code>cookie</code>，但是体验下非常不好。一般我们会设置为<code>Lax</code>，但是安全性也就降低了，从导航到目标地址的<code>Get</code>也会携带<code>cookie</code>。所以<strong>这个方法也没解决通过<code>GET</code>携带参数来实现功能的<code>CSRF</code>的防御</strong>。</p>\n<p>另外在网上绝大多数都说这个属性是不支持子域的，其实错的。这个属性是描述跨站时<code>cookie</code>的携带方式，而不是跨域。也就是说只要设置好了<code>domain</code>，子域也能共享<code>cookie</code>，对于<code>ajax</code>需要设置<code>withCredentials</code>。</p>\n<h3 id=\"双重-cookie\">双重 cookie</h3>\n<p>既然<code>GET</code>请求来做功能和<code>SameSite</code>都无法防御，那我们索性将他们放行。然后加多一层验证，我们在服务端生成一段唯一的随机数并设置到<code>cookie</code>中，前端在请求前从<code>cookie</code>中获取到这个随机数，然后加入到请求体或请求<code>path</code>中。后端收到请求时第二层验证验证此参数与<code>cookie</code>中的是否一致。</p>\n<p>这个防御主要是针对<strong>CSRF是利用用户的凭证数据，无法直接窃取凭证</strong>来实施的，这样我们就解决了<code>GET</code>写单参数实现功能的<code>CSRF</code>防御了，但是这个方式也有一定的弊端。</p>\n<p>如果有多个子域，我们需要将这个<code>cookie</code>种在主域，这样每个子域才能访问得到它，难以做到子域隔离。如果子域有一个站点存在<code>XSS</code>漏洞被攻击，那攻击者就能拿到这个随机数，所有站点都有可能被<code>CSRF</code>攻击。</p>\n<h3 id=\"使用-token\">使用 token</h3>\n<p>这种方式也是类似双重<code>cookie</code>的原理，加多一层随机数验证。<code>token</code>是后端通过一段唯一的字符串 <em>(一般是随机数与时间戳组合)</em> 加密后生成，然后将<code>token</code>存储起来，并通过模板渲染嵌入到<code>html</code>，或者开放更新并返回<code>token</code>接口 <em>（一般指登录接口）</em> ，然后客户端在请求时携带上<code>token</code>的参数，后端在拦截器中验证<code>token</code>是否有效与是否过期，如果有效则放行，无效则拒绝。</p>\n<p>由于<code>CSRF</code>一般是在第三方进行，无法获取到<code>token</code>的，只要页面没有<code>XSS</code>漏洞泄露<code>Token</code>，那么<code>CSRF</code>攻击就无法成功。</p>\n<p>另外在前后端分离使用<code>token</code>认证来代替<code>cookie</code>认证用户身份最主流的方式。原理就在于服务端可以通过<code>token</code>关联用户信息，只要携带上<code>token</code>就可以知道是哪个用户，而前端获取到<code>token</code>后缓存到<code>localStorage</code>或<code>sessionStorage</code>中，并将<code>token</code>设置到全局请求头中，这样一来就可以代替<code>cookie</code>了，并且<code>Storage</code>的数据并不会跟随请求而被携带，能有效防范<code>CSRF</code>。</p>\n<h3 id=\"二次确认\">二次确认</h3>\n<p>在敏感接口比如转账，更改密码，注销账号等，还可以使用二次确认，比如再次输入密码或手机验证码也能防止<code>CSRF</code>攻击，而且比上面几种方式更安全。</p>\n<h2 id=\"中间人攻击\">中间人攻击</h2>\n<p>在<code>http</code>数据提交给<code>TCP</code>层之后，会经过用户电脑、路由器、运营商、服务器，这中间每一个环节，都不是安全的。因为<code>http</code>采用的是明文传输，攻击者可以通过<strong>中间环节对数据窃取、伪造、篡改</strong>这就是中间人攻击。</p>\n<p>为了防范中间人攻击，我们需要对传输的数据进行加密，确保私密性和完整性 <em>（防止修改）</em> 。而<code>https</code>就是干这件事的，在说明<code>https</code>的工作方式之前我们先了解一些相关词汇。</p>\n<h3 id=\"相关词汇\">相关词汇</h3>\n<p><strong>对称加密</strong>：对称算法是内容加密的一类算法。它有一个秘钥，通过秘钥解开加密内容。</p>\n<p><strong>非对称加密</strong>：非对称算法是内容加密的一类算法。它有两个秘钥，公钥与私钥。公钥是公开给所有人的，私钥是私密的，只有持有者知道。通过公钥加密后的内容只有通过私钥才能解密出来。非对称算法的安全性很高，但是因为计算量庞大，比较消耗性能。非对称加密算法可逆（可解密）。</p>\n<p><strong>认证</strong>：认证是指不在意传输内容被看到，只需要确保内容是完整的，传输方式正确的。</p>\n<p><strong>数字签名</strong>：数字签名是指发送方在发送源内容的同时也发送一份对源内容进行不可逆算法加密（签名）。接收方也通过相同算法对发送内容进行加密，查看加密后的内容是否与发送方一致，如果一致则内容可信。</p>\n<p><strong>证书中心，CA 认证，数字证书</strong>：在一些情况下，接收方的公钥可能被偷偷替换成其他劫持者的公钥，此时劫持者就可以与接收方通话，所以就需要 CA 认证。CA 会用自己的私钥给要认证的公钥及其他一些信息进行签名，然后发送给持有者，持有者在发送数据时将 CA 认证后的数字签名发送给接收方，接收方通过 CA 给的公钥验签，验签通过认为是安全的公钥。</p>\n<h3 id=\"https通讯的过程\"><code>https</code>通讯的过程</h3>\n<ol>\n<li>浏览器发送起往服务器的<code>443</code>端口请求，并携带了浏览器支持的加密算法和 hash 算法</li>\n<li>服务器收到请求，选择浏览器支持的加密算法和哈希算法</li>\n<li>服务器将数字证书返回给浏览器，这个证书可以是可靠机构申请的，也可以是自制的</li>\n<li>浏览器进入数字证书认证环境，这一部分是由浏览器的 TLS 完成的<ol>\n<li>首先浏览器会从内置的证书列表中找到数字证书的机构，如果找不到则会提示用户该证书不是权威机构颁发，是不可信任的，如果找到证书机构，则取出机构颁发的公钥</li>\n<li>浏览器使用机构公钥对数字证书验签验签通过则拿出内容，内容包括网站的公钥、网址、证书的有效期等。浏览器会先验证证书签名的合法性（数字签名）。签名通过后在查看证书记录的网址是否与当前网址一致，查看证书是否过期。</li>\n<li>浏览器生成随机数 R，并使用网站的公钥对 R 进行加密</li>\n</ol>\n</li>\n<li>浏览器将加密后的 R 发送给服务器</li>\n<li>服务器用私钥解密得到 R</li>\n<li>服务器以 R 为秘钥使用对称加密算法加密网页内容并传输给浏览器</li>\n<li>浏览器以 R 为秘钥使用之前约定好的解密算法获取网页内容</li>\n</ol>\n<p>前 5 步其实就是<code>https</code>握手过程，主要是认证服务端证书的合法性。因为非对称计算量比较大， <strong>整个通讯过程只会用到一次非对称加密算法</strong>（主要是用来保护传输客户端生成用于对称加密随机数秘钥）。<strong>后续内容的加解密都是用一开始约定好的对称加密算法进行的。</strong></p>\n<p>通过<code>https</code>的混合加密方式 <em>（非对称加密和对称加密结合）</em> 大大增加了中间人的攻击成本。但是<code>https</code>不是绝对安全的，下面例举一些情况</p>\n<ul>\n<li>一些软件会提示用户本地计算机安装根证书，这时这个软件就可以使用自签证书发起中间人攻击，大致流程如下<ul>\n<li>在中间环节将服务器发送过来的数字证书替换成自签的证书，并缓存数字证书；</li>\n<li>由于自签证书在根证书中，浏览器认证通过；</li>\n<li>浏览器使用自签公钥机密内容，软件使用自签私钥解密，获取请求内容，使用服务器公钥加密发送到服务器；</li>\n<li>服务器返回内容使用自签私钥进行签名，获取返回内容</li>\n</ul>\n</li>\n<li>CA私钥泄漏</li>\n<li>生成随机数R泄漏</li>\n</ul>\n<p>虽然不是绝对安全，但是已经是在现有架构下最好的解决方案了。</p>\n<p>完结撒花</p>\n<h2 id=\"相关阅读\">相关阅读</h2>\n<ul>\n<li><a href=\"https://bill-lai.github.io/article/f81b918881d6fe131603\">跨站请求如何携带凭证</a></li>\n<li><a href=\"https://bill-lai.github.io/article/2b99b3a4b5641cca38d3\">iframe,ajax,canvas跨域处理</a></li>\n</ul>\n","desc":"网络安全是用于保护关键系统和敏感信息免遭数字攻击的实践。本文例举了常见的网络安全问题及在前后端防范的方法。\nXSS（跨站脚本攻击）\nCross-Site Scripting（跨站脚本攻击）简称XSS，是一种代码注入攻击。攻击者通过在目标网站上注入脚本，让它运行在用户浏览器上，利用这些脚本可以获取用户","column":{"title":"http","id":"72990761b6dfce2c298d"}}