<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="theme-color" content="#000000"/><link rel="icon" href="/static/images/favicon.ico"/><link rel="apple-touch-icon" href="/static/images/logo192.png"/><link rel="stylesheet" href="/static/lib/simplemde.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-0L4WRG1D3N"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0L4WRG1D3N")</script><title>vue3-ref源码解析 | bill-lai 的博客</title><link href="/static/css/main.8f23dd88.chunk.css" rel="stylesheet"></head><body><input placeholder=""><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="style_app__1yczT"><header class="style_slide__z5PNT style_slide__3Yi3e"><a href="/"><img src="/static/media/portrait.df7a5375.jpg" class="style_portrait__2GrBh" alt="portrait"/></a><div class="style_content__3GlZB"><div class="style_introduce__2UxnL"><h1><a href="/">bill-lai</a></h1><p>专注 WEB 端开发</p></div><ul class="style_navs__2yN9I"><li><a href="/">首页</a></li><li><a href="/archive">专题</a></li><li><a href="/special">归档</a></li></ul></div></header><div class="style_body__3Yz5T"><div class="style_layer__1ZQZt"><div class="style_main__XnHDF"><div> <h1 class="main-title">vue3-ref源码解析<span class="marker">2022-02-18 17:31</span></h1><div class="marked-body"><div><h2 id="阅读准备">阅读准备</h2>
<blockquote>
<p>本文使用的<code>vue</code>版本为<code>3.2.26</code>。在阅读 <code>ref</code> 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 <code>API</code>了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。</p>
</blockquote>
<p>&emsp;&emsp;我们前两章讲讲解了<a href="https://bill-lai.github.io/article/6452d43210bfdd32fd3c">reactive 源码解析</a>和<a href="https://bill-lai.github.io/article/37495e00ab36e870f8dd">effect 源码解析</a>，并且知道了它们是如何实现响应式的，还没看过的小伙伴可以先阅读一下。我们回顾一下，<code>reactive</code>函数可以创建通过<code>Proxy</code>实现的响应式对象，响应式对象需要在<code>effect</code>中使用才能收集到依赖，在更改响应式对象时，代理会通过<code>trigger</code>通知所有依赖的<code>effect</code>对象，并执行<code>effect</code>的监听方法。</p>
<p>&emsp;&emsp;因为<code>reactive</code>创建的响应式对象是通过<code>Proxy</code>来实现的，所以传入数据不能为基础类型，比如<code>number</code>、<code>string</code>、<code>boolean</code>。创建回来的对象必须保持它的引用，不能重新赋值，这样会失去响应式的特征，比如：</p>
<pre><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> effect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> reuser <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"bill"</span><span class="token punctuation">,</span> sex<span class="token operator">:</span> <span class="token string">"男"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">18</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>reuser<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的性别为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>reuser<span class="token punctuation">.</span>sex<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，年龄为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>reuser<span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">岁</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> change <span class="token operator">=</span> <span class="token punctuation">{</span> sex<span class="token operator">:</span> <span class="token string">"女"</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">19</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 更改了proxy的指向，失去响应式特征，并且在下一次垃圾回收会回收掉之前的proxy</span>
reuser <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>reuser<span class="token punctuation">,</span>
  <span class="token operator">...</span>change<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;上方代码为了合并修改项将两个对象展开到一个对象中，这样更改会丢失<code>proxy</code>的指向，失去响应式特征，并且在下一次垃圾回收会回收掉之前的<code>proxy</code>，所以只能够找到修改属性，在原来的<code>proxy</code>基础上一个一个修改。</p>
<p>&emsp;&emsp;<code>ref</code>对象是对<code>reactive</code>不支持的数据的一个补充，让如基础数据响应式进行支持，以及更方便的对象替换操作推出的。下面我们先了解一下<code>ref</code>的特性。</p>
<ul>
<li><p>使用<code>ref</code>或<code>shallowRef</code>函数创建<code>ref</code>对象，<code>ref</code>通过<code>value</code>属性进行访问和修改传入参数。</p>
</li>
<li><p>与<code>reactive</code>不同，<code>ref</code>的参数没有任何限制。</p>
</li>
<li><p>使用<code>reactive</code>可接受的对象为<code>ref</code>参数对象时，<code>isReactive(ref.value)</code>为<code>true</code>。</p>
</li>
<li><p><code>ref</code>在<code>effect</code>监听函数中使用可响应式</p>
</li>
<li><p><code>ref</code>在<code>effect</code>中只有<code>value</code>属性是可响应式的</p>
</li>
<li><p><code>customRef</code>可以创建自定义<code>getter</code>、<code>setter</code>的<code>ref</code>，创建时需要提供一个创建<code>get, set</code>工厂方法，工厂方法会传入收集方法和触发方法，由用户主动触发。如</p>
<pre><code class="language-js"><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> custom <span class="token operator">=</span> <span class="token function">customRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>track<span class="token punctuation">,</span> trigger<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><p>使用<code>toRef</code>可以通过<code>proxy</code>的某个属性生成为可以有默认值的<code>ref</code>对象</p>
</li>
<li><p>使用<code>toRefs</code>可以通过<code>proxy</code>的数据结构以及所有属性，生成与<code>proxy</code>数据结构一致的，所有属性值为<code>ref</code>对象的对象</p>
</li>
</ul>
<p>&emsp;&emsp;综合上面的特性和之前讲解<code>effect</code>的实现原理，能猜得到<code>ref</code>对象会对<code>value</code>属性的修改和获取时进行拦截，在<code>value</code>被<code>get</code>的时候收集依赖，在<code>set</code>的时候获取依赖关联的<code>effect</code>再触发依赖函数。<code>ref</code>对属性修改和获取时不能通过<code>proxy</code>来实现，<code>ref</code>支持基础类型而<code>proxy</code>不支持。收集依赖时不能使用<code>effect</code>文件中的<code>targetMap</code>关联<code>effect</code>，<code>targetMap</code>是<code>WeakMap</code>类型，<code>WeakMap</code>类型仅支持对象作为<code>key</code>，不支持基础类型。</p>
<h2 id="ref-和-shallowref">ref 和 shallowRef</h2>
<p>&emsp;&emsp;接下来我们看看<code>ref</code>和<code>shallowRef</code>的具体实现：</p>
<pre><code class="language-js"><span class="token comment">// 是否是ref根据属性的__v_isRef决定</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isRef</span><span class="token punctuation">(</span>r<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> r <span class="token keyword">is</span> Ref <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">Boolean</span><span class="token punctuation">(</span>r <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">.</span>__v_isRef <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">ref</span><span class="token punctuation">(</span>value<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">createRef</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">shallowRef</span><span class="token punctuation">(</span>value<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">createRef</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建ref对象，传入raw和是否是shallow</span>
<span class="token keyword">function</span> <span class="token function">createRef</span><span class="token punctuation">(</span>rawValue<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> shallow<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果之前时ref则直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRef</span><span class="token punctuation">(</span>rawValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> rawValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RefImpl</span><span class="token punctuation">(</span>rawValue<span class="token punctuation">,</span> shallow<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;与<code>reactive</code>一样<code>ref</code>创建的响应式对象也分为是否是<code>shallow</code>，<code>ref</code>对象支持对<code>value</code>深度响应式，也就是说<code>ref.value.a.b</code>中的修改都能被拦截，<code>shallowRef</code>对象只支持对<code>value</code>值的响应式。</p>
<p>&emsp;&emsp;<code>ref</code>和<code>shallowRef</code>函数都使用<code>createRef</code>来创建<code>ref</code>对象，只是参数的区别。创建的<code>ref</code>对象会附加<code>__v_isRef</code>属性来标识是否是<code>ref</code>对象。在创建<code>ref</code>对象之前会检查入参是否是<code>ref</code>如果是就直接返回入参参数。</p>
<p>&emsp;&emsp;我们看到<code>ref</code>函数创建的真实对象是<code>RefImpl</code>，采用了<code>class</code>写法，将<code>raw</code>和<code>shallow</code>作为构造函数，下面我们看看这个<code>class</code>的实现：</p>
<pre><code class="language-js"><span class="token comment">// Ref对象类</span>
<span class="token keyword">class</span> <span class="token class-name">RefImpl<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token comment">// 存放 reactive(raw) 后的proxy</span>
  <span class="token keyword">private</span> _value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token comment">// 存放 raw</span>
  <span class="token keyword">private</span> _rawValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

  <span class="token comment">// 建立与effect的关系</span>
  <span class="token keyword">public</span> dep<span class="token operator">?</span><span class="token operator">:</span> Dep <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token comment">// 是否ref的标识</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> __v_isRef <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token comment">// 构造，传入raw 和 shallow</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token keyword">readonly</span> _shallow<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 存储 raw</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_rawValue <span class="token operator">=</span> _shallow <span class="token operator">?</span> value <span class="token operator">:</span> <span class="token function">toRaw</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果是不是shallow则 存储 reactive proxy 否则存储传入参数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_value <span class="token operator">=</span> _shallow <span class="token operator">?</span> value <span class="token operator">:</span> <span class="token function">toReactive</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// getter value拦截器</span>
  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// track Ref 收集依赖</span>
    <span class="token function">trackRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// setter value拦截器</span>
  <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是需要深度响应的则获取 入参的raw</span>
    newVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_shallow <span class="token operator">?</span> newVal <span class="token operator">:</span> <span class="token function">toRaw</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 查看要设置值是否与当前值是否修改</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasChanged</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_rawValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 存储新的 raw</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_rawValue <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
      <span class="token comment">// 更新value 如果是深入创建的还需要转化为reactive代理</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_shallow <span class="token operator">?</span> newVal <span class="token operator">:</span> <span class="token function">toReactive</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 触发value，更新关联的effect</span>
      <span class="token function">triggerRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;如果不是<code>shallow</code>传入的<code>value</code>会通过<code>toReactive</code>转化为<code>reactive</code>，然后存在<code>ref._value</code>中。在<code>get</code>的时候直接返回这个<code>reactive</code>，这就是使用<code>reactive</code>可接受的对象为<code>ref</code>参数对象时，<code>isReactive(ref.value)</code>为<code>true</code>的原因，也是为什么能深度响应的原因。</p>
<p>&emsp;&emsp;<code>ref</code>还会存储入参和<code>set</code>的原始值，如果不是<code>shallow</code>则通过<code>toRaw</code>获取，存储在<code>_rawValue</code>属性中，存储这个值是为了能正确的判断值是否被修改。所以下方这种情况是不会调用<code>triggerRefValue</code>的，因为原始值是一样的。</p>
<pre><code class="language-js"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"bill"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> reTarget <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> targetRef <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>reTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>

targetRef<span class="token punctuation">.</span>value <span class="token operator">=</span> target<span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;<code>ref</code>对象还有个非常重要的属性<code>dep</code>，这里的<code>dep</code>与我们之前在<code>effect</code>一章讲的<code>dep</code>是一样的，没看过的同学可以<a href="https://bill-lai.github.io/article/37495e00ab36e870f8dd#dep">去看一下</a>。我们简单回顾一下。</p>
<p>&emsp;&emsp;<code>reactive</code>对象是通过<code>targetMap</code>与<code>Dep</code>关联的。<code>reactive</code>收集时通过<code>track</code>函数获取<code>dep</code>，然后通过<code>dep</code>对象调用<code>trackEffects</code>函数来将<code>effect</code>与<code>Dep</code>关联。</p>
<p>&emsp;&emsp;<code>reactive</code>触发时通过<code>trigger</code>函数整理相关联的多个<code>dep</code>最终合并成一个<code>dep</code>，然后通过<code>dep</code>调用<code>triggerEffects</code>获取关联的<code>effect</code>收集函数并触发。</p>
<p>&emsp;&emsp;<code>dep</code>中的具体细节管理是通过<code>trackEffects</code>函数和<code>effect</code>对象管理的，将<code>dep</code>与<code>effect</code>是由<code>trackEffects</code>函数处理的， 触发是由<code>triggerEffects</code>函数执行的。</p>
<p>&emsp;&emsp;也就是说<strong>基于现有<code>effect</code>的基础上，创建响应式对象只需要收集时获取<code>dep</code>并调用<code>trackEffects(dep)</code>， 触发时获取收集时的<code>dep</code>并调用<code>triggerEffects(dep)</code>。</strong><code>dep</code>属性就是<code>ref</code>能成为响应式对象的根本原因。</p>
<p>&emsp;&emsp;接下来我们看看<code>ref</code>是如何实现<code>trackEffects(dep)</code>和<code>triggerEffects(dep)</code>的。<code>ref</code>在<code>get value</code>时会调用<code>trackRefValue</code>，在<code>set value</code>时，如果<code>value</code>值发生了更改则调用<code>triggerRefValue</code>。可以猜到这两个方法就是实现响应式的关键，接下来我们看看他们的具体实现</p>
<pre><code class="language-js"><span class="token comment">// 收集 ref 依赖 调用trackEffects(dep)</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">trackRefValue</span><span class="token punctuation">(</span>ref<span class="token operator">:</span> RefBase<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果当前开启了跟踪</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取raw ref数据</span>
    ref <span class="token operator">=</span> <span class="token function">toRaw</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果当前ref还未初始化dep则创建</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ref<span class="token punctuation">.</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>dep <span class="token operator">=</span> <span class="token function">createDep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果是开发环境，则传入track细节,</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">trackEffects</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>dep<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        target<span class="token operator">:</span> ref<span class="token punctuation">,</span>
        type<span class="token operator">:</span> TrackOpTypes<span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">,</span>
        key<span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">trackEffects</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 触发 ref 调用trackEffects(dep)</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">triggerRefValue</span><span class="token punctuation">(</span>ref<span class="token operator">:</span> RefBase<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">,</span> newVal<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取raw ref数据</span>
  ref <span class="token operator">=</span> <span class="token function">toRaw</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果当前ref 有关联的dep</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果当前是开发环境则发送具体触发细节</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffects</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>dep<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        target<span class="token operator">:</span> ref<span class="token punctuation">,</span>
        <span class="token comment">// SET引起的变化</span>
        type<span class="token operator">:</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">SET</span><span class="token punctuation">,</span>
        key<span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">,</span>
        newValue<span class="token operator">:</span> newVal<span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffects</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>trackRefValue</code>会在适当的时候初始化<code>dep</code>并调用<code>trackEffects</code>，<code>triggerRefValue</code>会获取<code>ref</code>的<code>dep</code>并调用<code>triggerEffects</code>，就是我们上面说的内容。</p>
<p>&emsp;&emsp;大家注意到传入的<code>ref</code>会调用<code>toRaw</code>方法来重新赋值，这个方法是获取<code>reactive</code>的原始数据的。因为用户可能使用<code>reactive(ref(raw))</code>来获取数据，如果直接使用可能会收集到<code>dep</code>属性的依赖。另外大家思考一下下面这段代码的<code>effect</code>监听函数会触发几次？</p>
<pre><code class="language-js"><span class="token keyword">const</span> countRef <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> reCount <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>countRef<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reCount<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reCount<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;答案是四次，第一次是首次收集依赖，<code>reactive</code>会收到<code>value</code>的获取，存储<code>value</code>属性的<code>dep</code>附加到<code>targetMap</code>。然后调用<code>ref.value</code>，<code>ref</code>在获取<code>value</code>时会调用<code>trackRefValue</code>，创建<code>dep</code>附加到自身属性上。注意<code>ref.value</code>返回<code>this._value</code>，这时候<code>reactive</code>收到<code>_value</code>属性的获取，存储<code>_value</code>属性的<code>dep</code>，附加到<code>targetMap</code>中。所以创建了三个<code>dep</code>。当发生更改新值存储到<code>ref._value</code>中，而对于<code>reactive</code>来说<code>value</code>和<code>_value</code>是完全没关联的所以会触发两次，而<code>ref</code>自身会触发一次没所以一共是四次。</p>
<h2 id="customref">customRef</h2>
<p>&emsp;&emsp;接下来我们看看自定义<code>ref</code>方法<code>customRef</code>是如何实现的：</p>
<pre><code class="language-js"><span class="token comment">// 自定义ref对象类</span>
<span class="token keyword">class</span> <span class="token class-name">CustomRefImpl<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token comment">// 依赖dep 存储effets</span>
  <span class="token keyword">public</span> dep<span class="token operator">?</span><span class="token operator">:</span> Dep <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

  <span class="token comment">// 缓存getter setter</span>
  <span class="token keyword">private</span> <span class="token keyword">readonly</span> _get<span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span>CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">readonly</span> _set<span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span>CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">>></span><span class="token punctuation">[</span><span class="token string">"set"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// mark ref</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> __v_isRef <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token comment">// 传入ref工厂函数</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>factory<span class="token operator">:</span> CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构建getter setter，传入track trigger函数</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> get<span class="token punctuation">,</span> set <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">trackRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">triggerRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_get <span class="token operator">=</span> get<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_set <span class="token operator">=</span> set<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建自定义ref</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">customRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>factory<span class="token operator">:</span> CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CustomRefImpl</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>customRef</code>会创建<code>CustomRefImpl</code>的一个实例并返回，<code>CustomRefImpl</code>的实现和<code>Ref</code>差不多，使用<code>trackRefValue</code>和<code>triggerRefValue</code>将<code>dep</code>与<code>effect</code>关联实现响应式。不过<code>CustomRefImpl</code>会在工厂函数中传入<code>trackRefValue</code>和<code>triggerRefValue</code>，将收集依赖和触发执行权交给用户。让用户在适当的时候调用。在使用<code>value</code>时候调用生产的<code>get</code>方法，在设置<code>value</code>是调用生产的<code>set</code>方法。一般是在<code>get</code>的时候调用收集函数，<code>set</code>的时候触发函数。</p>
<h2 id="torefs-和-objectrefimpl">toRefs 和 ObjectRefImpl</h2>
<p>&emsp;&emsp;我们在使用<code>reactive</code>时通过缓存属性值很可能会失去响应式特性。因为属性值可能是<code>reactive</code>不支持深入响应的值，这时候缓存属性值，或者是通过<code>ES6</code>解构出来的值是不具备响应特性的。比如在下面这两种使用方式：</p>
<pre><code class="language-js"><span class="token keyword">const</span> reuser <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"bill"</span><span class="token punctuation">,</span> sex<span class="token operator">:</span> <span class="token string">"男"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> reuser<span class="token punctuation">;</span>
<span class="token keyword">const</span> sex <span class="token operator">=</span> reuser<span class="token punctuation">.</span>sex<span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;这样的话就得一直使用<code>reuser.name</code>的方式来进行访问，<code>vue</code>有两个<code>api</code>能很好的解决这个问题，就是<code>toRef</code>和<code>toRefs</code>。</p>
<p>&emsp;&emsp;<code>toRef</code>通过<code>reactive</code>代理和代理的某个属性生成为<code>ref</code>并且可以携带默认值。而<code>toRefs</code>根据<code>reactive</code>代理生成所有属性值为<code>ref</code>的对象。生成的<code>ref</code>的<code>value</code>是代理属性值的映射，两端更改都会实时同步，我们看看是如何使用的：</p>
<pre><code class="language-js"><span class="token keyword">const</span> reuser <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"bill"</span><span class="token punctuation">,</span> sex<span class="token operator">:</span> <span class="token string">"男"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>reuser<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"未命名"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> sex <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>reuser<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reuser<span class="token punctuation">.</span>name<span class="token punctuation">,</span> reuser<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bill 男</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>value<span class="token punctuation">,</span> sex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bill 男</span>

name<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">"lzb"</span><span class="token punctuation">;</span>
sex<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">"女"</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reuser<span class="token punctuation">.</span>name<span class="token punctuation">,</span> reuser<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//lzb 女</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>value<span class="token punctuation">,</span> sex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//lzb 女</span>

<span class="token keyword">delete</span> reuser<span class="token punctuation">.</span>name<span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reuser<span class="token punctuation">.</span>name<span class="token punctuation">,</span> reuser<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//undefined 女</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>value<span class="token punctuation">,</span> sex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//未命名 女</span>
</code></pre>
<p>&emsp;&emsp;接下来我们看看<code>toRef</code>和<code>toRefs</code>的具体实现：</p>
<pre><code class="language-js"><span class="token comment">// 将proxy对象和目标的属性 转化为ref 并拥有默认值</span>
<span class="token keyword">class</span> <span class="token class-name">ObjectRefImpl<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> __v_isRef <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token comment">// 记录代理</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> _object<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>
    <span class="token comment">// 要辅助的key</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> _key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">,</span>
    <span class="token comment">// 默认值</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> _defaultValue<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 获取value</span>
  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> val <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_object<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>_key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> val <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_defaultValue <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_object<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>_key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将proxy对象和目标的属性 转化为ref 并拥有默认值</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">toRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  object<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">,</span>
  defaultValue<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token operator">:</span> ToRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> val <span class="token operator">=</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">isRef</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token operator">?</span> val
    <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObjectRefImpl</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> key<span class="token punctuation">,</span> defaultValue<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将proxy对象所有属性转化为ref值</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">toRefs</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span></span><span class="token punctuation">(</span>object<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> ToRefs<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment">// 只有内部代理才能toRefs</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isProxy</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">toRefs() expects a reactive object but received a plain one.</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 分别对所有属性toRef</span>
  <span class="token keyword">const</span> ret<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token function">isArray</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>object<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>toRef</code>会先查看<code>proxy[key]</code>是否是<code>ref</code>如果是的话直接返回，如果不是则创建<code>ObjectRefImpl</code>并且将参数传入，<code>ObjectRefImpl</code>会标识当前对象是<code>ref</code>类型 <em>（通过<code>__v_isRef</code>属性）</em> ，并且缓存<code>proxy</code>、<code>key</code>和默认值。<code>get value</code>时直接通过<code>proxy[key]</code>来获取并返回，如果回去的值是<code>undefined</code>则使用默认值。<code>set value</code>时则通过<code>proxy[key] = newVal</code>来设置。</p>
<p>&emsp;&emsp;<code>toRefs</code>则是将每个属性都调用一次没有默认值的<code>toRef</code>，并且返回与<code>proxy</code>一致的数据结构。</p>
<p>&emsp;&emsp;为什么这里的<code>ObjectRefImpl</code>类不需要<code>dep</code>属性和收集依赖和触发更改呢？这是因为<code>_object</code>属性本身是<code>proxy</code>类型，当我们在使用<code>proxy[key]</code>就实现了收集依赖，在<code>proxy[key] = newVal</code>是就触发了更改。</p>
<h2 id="其他辅助方法">其他辅助方法</h2>
<p>&emsp;&emsp;<code>ref</code>文件中还声明了其他辅助方法，比如<code>triggerRef</code>手动触发<code>ref</code>的更改使关联的<code>effect</code>重新执行收集函数；<code>unref</code>获取<code>ref</code>的原始值。这两个方法比较简单直接看源码即可，这里就不再讲解了。</p>
<pre><code class="language-js"><span class="token comment">// 手动触发 ref</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">triggerRef</span><span class="token punctuation">(</span>ref<span class="token operator">:</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 开发环境用当前值做最新值变化</span>
  <span class="token function">triggerRefValue</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> __DEV__ <span class="token operator">?</span> ref<span class="token punctuation">.</span>value <span class="token operator">:</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 解构ref，直接返回value</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">unref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ref<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">isRef</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span>value <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">:</span> ref<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;还有一个辅助方法<code>proxyRefs</code>，这个方法将一个对象直属属性内的所有<code>ref</code>属性值解构访问 <em>（不需要通过<code>value</code>下标访问）</em> 。什么是直属属性就是第一层属性，比如下方的代码：</p>
<pre><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"bill"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> unUser <span class="token operator">=</span> <span class="token function">proxyRefs</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  name<span class="token operator">:</span> name<span class="token punctuation">,</span>
  adderss<span class="token operator">:</span> <span class="token punctuation">{</span>
    city<span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"珠海"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>unUser<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bill</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>unUser<span class="token punctuation">.</span>address<span class="token punctuation">.</span>city<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Ref</span>

unUser<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"lzb"</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>unUser<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lzb</span>
</code></pre>
<!-- `vue`组件之间传递参数的`props`就是通过这个函数来处理的，所以在父级中使用`ref` -->

<p><code>proxyRefs</code>只对第一层属性的<code>ref</code>解构。我们看看它的源码：</p>
<pre><code class="language-js"><span class="token comment">// 浅解构ref处理器</span>
<span class="token keyword">const</span> shallowUnwrapHandlers<span class="token operator">:</span> ProxyHandler<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// getter将unref方便访问</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">unref</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// setter先查看是否是ref，如果是则更新value</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果新数据不是ref但旧数据是则更新value</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRef</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRef</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldValue<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建代理ref 解构方便使用</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">proxyRefs</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">></span></span></span><span class="token punctuation">(</span>
  objectWithRefs<span class="token operator">:</span> <span class="token constant">T</span>
<span class="token punctuation">)</span><span class="token operator">:</span> ShallowUnwrapRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果是reactive对象则无需解构</span>
  <span class="token keyword">return</span> <span class="token function">isReactive</span><span class="token punctuation">(</span>objectWithRefs<span class="token punctuation">)</span>
    <span class="token operator">?</span> objectWithRefs
    <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>objectWithRefs<span class="token punctuation">,</span> shallowUnwrapHandlers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;当<code>proxyRefs</code>入参是<code>reactive</code>对象时则直接返回，<code>reactive</code>对象本身会对<code>ref</code>解构，而且是深度的，这里就不需要处理。<strong>有个特殊情况<code>shallowReactive</code>对象不会对<code>ref</code>解构，但是也直接返回了，也就是说这个方法对<code>shallowReactive</code>对象时无效的！</strong></p>
<p>&emsp;&emsp;如果<code>proxyRefs</code>入参不是<code>reactive</code>对象，则创建代理，<code>get</code>拦截器通过<code>unref</code>来获取值返回，<code>set</code>拦截器通过判断当前要更新的是否是<code>ref</code>如果是则更新<code>value</code>。</p>
<p>&emsp;&emsp;到这里我们<code>ref</code>的所有内容就已经讲完了，接下来日常小结。</p>
<h2 id="小结">小结</h2>
<ul>
<li><strong><code>ref</code>对象自身附加了<code>dep</code>，在收集依赖时通过<code>trackEffects</code>函数，触发时通过<code>triggerEffects</code>函数</strong></li>
<li><strong><code>ref</code>能够创建深度响应式是依赖了<code>reactive</code></strong></li>
<li><strong><code>Proxy</code>代理对象可以通过<code>toRef</code>和<code>toRefs</code>辅助方法保持对单个属性的引用，赋值修改会映射到<code>Proxy</code></strong></li>
<li><strong><code>customRef</code>函数可以创建自由度极高的响应式对象</strong></li>
</ul>
<p>上一章：<a href="https://bill-lai.github.io/article/37495e00ab36e870f8dd">vue3-effect 源码解析</a><br>下一章：<a href="https://bill-lai.github.io/article/b9bbb26eba4dacdc2312">vue3-computed 源码解析</a></p>
</div></div><div class="style_article-loading-layer__3poja"><div class="style_layer__GxMiF"><div style="fill:var(--vice-color);height:64px;width:64px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle transform="translate(8 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(16 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.3"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(24 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.6"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
</svg>
</div></div></div> </div><div class="style_bottom__29qYA"><p>©2021 - bill-lai 的小站 -<a rel="noreferrer" href="https://github.com/bill-lai/bill-lai.github.io" target="_blank">站点源码</a></p><p>本站使用<a rel="noreferrer" target="_blank" href="https://react.docschina.org/docs/hooks-reference.html#usememo">ReactHook</a><a rel="noreferrer" target="_blank" href="https://www.typescriptlang.org/zh/">TypeScript</a><a rel="noreferrer" target="_blank" href="https://docs.github.com/cn/rest">githubAPI</a><a rel="noreferrer" target="_blank" href="https://simplemde.com/">SimpleMDE</a>制作</p></div></div><div class="style_right-layer__Rm9TS "><div class="style_right__3hdcL"><div class="style_right-content__F68mu"><div class="navigation"><h4 class="style_title__1aA1F">目录列表</h4><ul class="style_top-navs__3vyAr"><li class=""><span>阅读准备<!-- --> </span></li><li class=""><span>ref 和 shallowRef<!-- --> </span></li><li class=""><span>customRef<!-- --> </span></li><li class=""><span>toRefs 和 ObjectRefImpl<!-- --> </span></li><li class=""><span>其他辅助方法<!-- --> </span></li><li class=""><span>小结<!-- --> </span></li></ul></div></div></div></div></div></div></div></div>
        <script>var globalState = {"article/4838fc56a04f95936f16":{"title":"vue3-ref源码解析","id":"4838fc56a04f95936f16","mtime":1645176674132,"ctime":1644914753060,"issues":{"number":19,"commentsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/19/comments","reactionsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/19/reactions"},"head":null,"foot":null,"dirs":[{"leave":2,"title":"阅读准备","children":[]},{"leave":2,"title":"ref 和 shallowRef","children":[]},{"leave":2,"title":"customRef","children":[]},{"leave":2,"title":"toRefs 和 ObjectRefImpl","children":[]},{"leave":2,"title":"其他辅助方法","children":[]},{"leave":2,"title":"小结","children":[]}],"body":"<h2 id=\"阅读准备\">阅读准备</h2>\n<blockquote>\n<p>本文使用的<code>vue</code>版本为<code>3.2.26</code>。在阅读 <code>ref</code> 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 <code>API</code>了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。</p>\n</blockquote>\n<p>&emsp;&emsp;我们前两章讲讲解了<a href=\"https://bill-lai.github.io/article/6452d43210bfdd32fd3c\">reactive 源码解析</a>和<a href=\"https://bill-lai.github.io/article/37495e00ab36e870f8dd\">effect 源码解析</a>，并且知道了它们是如何实现响应式的，还没看过的小伙伴可以先阅读一下。我们回顾一下，<code>reactive</code>函数可以创建通过<code>Proxy</code>实现的响应式对象，响应式对象需要在<code>effect</code>中使用才能收集到依赖，在更改响应式对象时，代理会通过<code>trigger</code>通知所有依赖的<code>effect</code>对象，并执行<code>effect</code>的监听方法。</p>\n<p>&emsp;&emsp;因为<code>reactive</code>创建的响应式对象是通过<code>Proxy</code>来实现的，所以传入数据不能为基础类型，比如<code>number</code>、<code>string</code>、<code>boolean</code>。创建回来的对象必须保持它的引用，不能重新赋值，这样会失去响应式的特征，比如：</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> reactive<span class=\"token punctuation\">,</span> effect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"vue\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> reuser <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"bill\"</span><span class=\"token punctuation\">,</span> sex<span class=\"token operator\">:</span> <span class=\"token string\">\"男\"</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> <span class=\"token number\">18</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>reuser<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">的性别为</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>reuser<span class=\"token punctuation\">.</span>sex<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">，年龄为</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>reuser<span class=\"token punctuation\">.</span>age<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">岁</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> change <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> sex<span class=\"token operator\">:</span> <span class=\"token string\">\"女\"</span><span class=\"token punctuation\">,</span> age<span class=\"token operator\">:</span> <span class=\"token number\">19</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 更改了proxy的指向，失去响应式特征，并且在下一次垃圾回收会回收掉之前的proxy</span>\nreuser <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>reuser<span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>change<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&emsp;&emsp;上方代码为了合并修改项将两个对象展开到一个对象中，这样更改会丢失<code>proxy</code>的指向，失去响应式特征，并且在下一次垃圾回收会回收掉之前的<code>proxy</code>，所以只能够找到修改属性，在原来的<code>proxy</code>基础上一个一个修改。</p>\n<p>&emsp;&emsp;<code>ref</code>对象是对<code>reactive</code>不支持的数据的一个补充，让如基础数据响应式进行支持，以及更方便的对象替换操作推出的。下面我们先了解一下<code>ref</code>的特性。</p>\n<ul>\n<li><p>使用<code>ref</code>或<code>shallowRef</code>函数创建<code>ref</code>对象，<code>ref</code>通过<code>value</code>属性进行访问和修改传入参数。</p>\n</li>\n<li><p>与<code>reactive</code>不同，<code>ref</code>的参数没有任何限制。</p>\n</li>\n<li><p>使用<code>reactive</code>可接受的对象为<code>ref</code>参数对象时，<code>isReactive(ref.value)</code>为<code>true</code>。</p>\n</li>\n<li><p><code>ref</code>在<code>effect</code>监听函数中使用可响应式</p>\n</li>\n<li><p><code>ref</code>在<code>effect</code>中只有<code>value</code>属性是可响应式的</p>\n</li>\n<li><p><code>customRef</code>可以创建自定义<code>getter</code>、<code>setter</code>的<code>ref</code>，创建时需要提供一个创建<code>get, set</code>工厂方法，工厂方法会传入收集方法和触发方法，由用户主动触发。如</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> custom <span class=\"token operator\">=</span> <span class=\"token function\">customRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>track<span class=\"token punctuation\">,</span> trigger<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">track</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>newValue<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    value <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">trigger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n<li><p>使用<code>toRef</code>可以通过<code>proxy</code>的某个属性生成为可以有默认值的<code>ref</code>对象</p>\n</li>\n<li><p>使用<code>toRefs</code>可以通过<code>proxy</code>的数据结构以及所有属性，生成与<code>proxy</code>数据结构一致的，所有属性值为<code>ref</code>对象的对象</p>\n</li>\n</ul>\n<p>&emsp;&emsp;综合上面的特性和之前讲解<code>effect</code>的实现原理，能猜得到<code>ref</code>对象会对<code>value</code>属性的修改和获取时进行拦截，在<code>value</code>被<code>get</code>的时候收集依赖，在<code>set</code>的时候获取依赖关联的<code>effect</code>再触发依赖函数。<code>ref</code>对属性修改和获取时不能通过<code>proxy</code>来实现，<code>ref</code>支持基础类型而<code>proxy</code>不支持。收集依赖时不能使用<code>effect</code>文件中的<code>targetMap</code>关联<code>effect</code>，<code>targetMap</code>是<code>WeakMap</code>类型，<code>WeakMap</code>类型仅支持对象作为<code>key</code>，不支持基础类型。</p>\n<h2 id=\"ref-和-shallowref\">ref 和 shallowRef</h2>\n<p>&emsp;&emsp;接下来我们看看<code>ref</code>和<code>shallowRef</code>的具体实现：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 是否是ref根据属性的__v_isRef决定</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">isRef</span><span class=\"token punctuation\">(</span>r<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> r <span class=\"token keyword\">is</span> Ref <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">Boolean</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">&amp;&amp;</span> r<span class=\"token punctuation\">.</span>__v_isRef <span class=\"token operator\">===</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">shallowRef</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 创建ref对象，传入raw和是否是shallow</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span>rawValue<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">,</span> shallow<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 如果之前时ref则直接返回</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isRef</span><span class=\"token punctuation\">(</span>rawValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> rawValue<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RefImpl</span><span class=\"token punctuation\">(</span>rawValue<span class=\"token punctuation\">,</span> shallow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;与<code>reactive</code>一样<code>ref</code>创建的响应式对象也分为是否是<code>shallow</code>，<code>ref</code>对象支持对<code>value</code>深度响应式，也就是说<code>ref.value.a.b</code>中的修改都能被拦截，<code>shallowRef</code>对象只支持对<code>value</code>值的响应式。</p>\n<p>&emsp;&emsp;<code>ref</code>和<code>shallowRef</code>函数都使用<code>createRef</code>来创建<code>ref</code>对象，只是参数的区别。创建的<code>ref</code>对象会附加<code>__v_isRef</code>属性来标识是否是<code>ref</code>对象。在创建<code>ref</code>对象之前会检查入参是否是<code>ref</code>如果是就直接返回入参参数。</p>\n<p>&emsp;&emsp;我们看到<code>ref</code>函数创建的真实对象是<code>RefImpl</code>，采用了<code>class</code>写法，将<code>raw</code>和<code>shallow</code>作为构造函数，下面我们看看这个<code>class</code>的实现：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// Ref对象类</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">RefImpl<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 存放 reactive(raw) 后的proxy</span>\n  <span class=\"token keyword\">private</span> _value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 存放 raw</span>\n  <span class=\"token keyword\">private</span> _rawValue<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 建立与effect的关系</span>\n  <span class=\"token keyword\">public</span> dep<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Dep <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 是否ref的标识</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> __v_isRef <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 构造，传入raw 和 shallow</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> _shallow<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 存储 raw</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_rawValue <span class=\"token operator\">=</span> _shallow <span class=\"token operator\">?</span> value <span class=\"token operator\">:</span> <span class=\"token function\">toRaw</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 如果是不是shallow则 存储 reactive proxy 否则存储传入参数</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value <span class=\"token operator\">=</span> _shallow <span class=\"token operator\">?</span> value <span class=\"token operator\">:</span> <span class=\"token function\">toReactive</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// getter value拦截器</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// track Ref 收集依赖</span>\n    <span class=\"token function\">trackRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// setter value拦截器</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果是需要深度响应的则获取 入参的raw</span>\n    newVal <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_shallow <span class=\"token operator\">?</span> newVal <span class=\"token operator\">:</span> <span class=\"token function\">toRaw</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 查看要设置值是否与当前值是否修改</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hasChanged</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_rawValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 存储新的 raw</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_rawValue <span class=\"token operator\">=</span> newVal<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 更新value 如果是深入创建的还需要转化为reactive代理</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_shallow <span class=\"token operator\">?</span> newVal <span class=\"token operator\">:</span> <span class=\"token function\">toReactive</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 触发value，更新关联的effect</span>\n      <span class=\"token function\">triggerRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> newVal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;如果不是<code>shallow</code>传入的<code>value</code>会通过<code>toReactive</code>转化为<code>reactive</code>，然后存在<code>ref._value</code>中。在<code>get</code>的时候直接返回这个<code>reactive</code>，这就是使用<code>reactive</code>可接受的对象为<code>ref</code>参数对象时，<code>isReactive(ref.value)</code>为<code>true</code>的原因，也是为什么能深度响应的原因。</p>\n<p>&emsp;&emsp;<code>ref</code>还会存储入参和<code>set</code>的原始值，如果不是<code>shallow</code>则通过<code>toRaw</code>获取，存储在<code>_rawValue</code>属性中，存储这个值是为了能正确的判断值是否被修改。所以下方这种情况是不会调用<code>triggerRefValue</code>的，因为原始值是一样的。</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"bill\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> reTarget <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> targetRef <span class=\"token operator\">=</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span>reTarget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ntargetRef<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&emsp;&emsp;<code>ref</code>对象还有个非常重要的属性<code>dep</code>，这里的<code>dep</code>与我们之前在<code>effect</code>一章讲的<code>dep</code>是一样的，没看过的同学可以<a href=\"https://bill-lai.github.io/article/37495e00ab36e870f8dd#dep\">去看一下</a>。我们简单回顾一下。</p>\n<p>&emsp;&emsp;<code>reactive</code>对象是通过<code>targetMap</code>与<code>Dep</code>关联的。<code>reactive</code>收集时通过<code>track</code>函数获取<code>dep</code>，然后通过<code>dep</code>对象调用<code>trackEffects</code>函数来将<code>effect</code>与<code>Dep</code>关联。</p>\n<p>&emsp;&emsp;<code>reactive</code>触发时通过<code>trigger</code>函数整理相关联的多个<code>dep</code>最终合并成一个<code>dep</code>，然后通过<code>dep</code>调用<code>triggerEffects</code>获取关联的<code>effect</code>收集函数并触发。</p>\n<p>&emsp;&emsp;<code>dep</code>中的具体细节管理是通过<code>trackEffects</code>函数和<code>effect</code>对象管理的，将<code>dep</code>与<code>effect</code>是由<code>trackEffects</code>函数处理的， 触发是由<code>triggerEffects</code>函数执行的。</p>\n<p>&emsp;&emsp;也就是说<strong>基于现有<code>effect</code>的基础上，创建响应式对象只需要收集时获取<code>dep</code>并调用<code>trackEffects(dep)</code>， 触发时获取收集时的<code>dep</code>并调用<code>triggerEffects(dep)</code>。</strong><code>dep</code>属性就是<code>ref</code>能成为响应式对象的根本原因。</p>\n<p>&emsp;&emsp;接下来我们看看<code>ref</code>是如何实现<code>trackEffects(dep)</code>和<code>triggerEffects(dep)</code>的。<code>ref</code>在<code>get value</code>时会调用<code>trackRefValue</code>，在<code>set value</code>时，如果<code>value</code>值发生了更改则调用<code>triggerRefValue</code>。可以猜到这两个方法就是实现响应式的关键，接下来我们看看他们的具体实现</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 收集 ref 依赖 调用trackEffects(dep)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">trackRefValue</span><span class=\"token punctuation\">(</span>ref<span class=\"token operator\">:</span> RefBase<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 如果当前开启了跟踪</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isTracking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 获取raw ref数据</span>\n    ref <span class=\"token operator\">=</span> <span class=\"token function\">toRaw</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 如果当前ref还未初始化dep则创建</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ref<span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      ref<span class=\"token punctuation\">.</span>dep <span class=\"token operator\">=</span> <span class=\"token function\">createDep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 如果是开发环境，则传入track细节,</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">trackEffects</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        target<span class=\"token operator\">:</span> ref<span class=\"token punctuation\">,</span>\n        type<span class=\"token operator\">:</span> TrackOpTypes<span class=\"token punctuation\">.</span><span class=\"token constant\">GET</span><span class=\"token punctuation\">,</span>\n        key<span class=\"token operator\">:</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">trackEffects</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 触发 ref 调用trackEffects(dep)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">triggerRefValue</span><span class=\"token punctuation\">(</span>ref<span class=\"token operator\">:</span> RefBase<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> newVal<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取raw ref数据</span>\n  ref <span class=\"token operator\">=</span> <span class=\"token function\">toRaw</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 如果当前ref 有关联的dep</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果当前是开发环境则发送具体触发细节</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">triggerEffects</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        target<span class=\"token operator\">:</span> ref<span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">// SET引起的变化</span>\n        type<span class=\"token operator\">:</span> TriggerOpTypes<span class=\"token punctuation\">.</span><span class=\"token constant\">SET</span><span class=\"token punctuation\">,</span>\n        key<span class=\"token operator\">:</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">,</span>\n        newValue<span class=\"token operator\">:</span> newVal<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">triggerEffects</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>trackRefValue</code>会在适当的时候初始化<code>dep</code>并调用<code>trackEffects</code>，<code>triggerRefValue</code>会获取<code>ref</code>的<code>dep</code>并调用<code>triggerEffects</code>，就是我们上面说的内容。</p>\n<p>&emsp;&emsp;大家注意到传入的<code>ref</code>会调用<code>toRaw</code>方法来重新赋值，这个方法是获取<code>reactive</code>的原始数据的。因为用户可能使用<code>reactive(ref(raw))</code>来获取数据，如果直接使用可能会收集到<code>dep</code>属性的依赖。另外大家思考一下下面这段代码的<code>effect</code>监听函数会触发几次？</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">const</span> countRef <span class=\"token operator\">=</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> reCount <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span>countRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>reCount<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nreCount<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&emsp;&emsp;答案是四次，第一次是首次收集依赖，<code>reactive</code>会收到<code>value</code>的获取，存储<code>value</code>属性的<code>dep</code>附加到<code>targetMap</code>。然后调用<code>ref.value</code>，<code>ref</code>在获取<code>value</code>时会调用<code>trackRefValue</code>，创建<code>dep</code>附加到自身属性上。注意<code>ref.value</code>返回<code>this._value</code>，这时候<code>reactive</code>收到<code>_value</code>属性的获取，存储<code>_value</code>属性的<code>dep</code>，附加到<code>targetMap</code>中。所以创建了三个<code>dep</code>。当发生更改新值存储到<code>ref._value</code>中，而对于<code>reactive</code>来说<code>value</code>和<code>_value</code>是完全没关联的所以会触发两次，而<code>ref</code>自身会触发一次没所以一共是四次。</p>\n<h2 id=\"customref\">customRef</h2>\n<p>&emsp;&emsp;接下来我们看看自定义<code>ref</code>方法<code>customRef</code>是如何实现的：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 自定义ref对象类</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomRefImpl<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 依赖dep 存储effets</span>\n  <span class=\"token keyword\">public</span> dep<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Dep <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 缓存getter setter</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> _get<span class=\"token operator\">:</span> ReturnType<span class=\"token operator\">&lt;</span>CustomRefFactory<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">[</span><span class=\"token string\">\"get\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> _set<span class=\"token operator\">:</span> ReturnType<span class=\"token operator\">&lt;</span>CustomRefFactory<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">[</span><span class=\"token string\">\"set\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// mark ref</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> __v_isRef <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 传入ref工厂函数</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>factory<span class=\"token operator\">:</span> CustomRefFactory<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 构建getter setter，传入track trigger函数</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> get<span class=\"token punctuation\">,</span> set <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">factory</span><span class=\"token punctuation\">(</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">trackRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">triggerRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_get <span class=\"token operator\">=</span> get<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_set <span class=\"token operator\">=</span> set<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">set</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_set</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 创建自定义ref</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">customRef</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>factory<span class=\"token operator\">:</span> CustomRefFactory<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Ref<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CustomRefImpl</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>customRef</code>会创建<code>CustomRefImpl</code>的一个实例并返回，<code>CustomRefImpl</code>的实现和<code>Ref</code>差不多，使用<code>trackRefValue</code>和<code>triggerRefValue</code>将<code>dep</code>与<code>effect</code>关联实现响应式。不过<code>CustomRefImpl</code>会在工厂函数中传入<code>trackRefValue</code>和<code>triggerRefValue</code>，将收集依赖和触发执行权交给用户。让用户在适当的时候调用。在使用<code>value</code>时候调用生产的<code>get</code>方法，在设置<code>value</code>是调用生产的<code>set</code>方法。一般是在<code>get</code>的时候调用收集函数，<code>set</code>的时候触发函数。</p>\n<h2 id=\"torefs-和-objectrefimpl\">toRefs 和 ObjectRefImpl</h2>\n<p>&emsp;&emsp;我们在使用<code>reactive</code>时通过缓存属性值很可能会失去响应式特性。因为属性值可能是<code>reactive</code>不支持深入响应的值，这时候缓存属性值，或者是通过<code>ES6</code>解构出来的值是不具备响应特性的。比如在下面这两种使用方式：</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">const</span> reuser <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"bill\"</span><span class=\"token punctuation\">,</span> sex<span class=\"token operator\">:</span> <span class=\"token string\">\"男\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> reuser<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> sex <span class=\"token operator\">=</span> reuser<span class=\"token punctuation\">.</span>sex<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>&emsp;&emsp;这样的话就得一直使用<code>reuser.name</code>的方式来进行访问，<code>vue</code>有两个<code>api</code>能很好的解决这个问题，就是<code>toRef</code>和<code>toRefs</code>。</p>\n<p>&emsp;&emsp;<code>toRef</code>通过<code>reactive</code>代理和代理的某个属性生成为<code>ref</code>并且可以携带默认值。而<code>toRefs</code>根据<code>reactive</code>代理生成所有属性值为<code>ref</code>的对象。生成的<code>ref</code>的<code>value</code>是代理属性值的映射，两端更改都会实时同步，我们看看是如何使用的：</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">const</span> reuser <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"bill\"</span><span class=\"token punctuation\">,</span> sex<span class=\"token operator\">:</span> <span class=\"token string\">\"男\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token function\">toRef</span><span class=\"token punctuation\">(</span>reuser<span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"未命名\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> sex <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">toRefs</span><span class=\"token punctuation\">(</span>reuser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>reuser<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> reuser<span class=\"token punctuation\">.</span>sex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//bill 男</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span> sex<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//bill 男</span>\n\nname<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"lzb\"</span><span class=\"token punctuation\">;</span>\nsex<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"女\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>reuser<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> reuser<span class=\"token punctuation\">.</span>sex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//lzb 女</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span> sex<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//lzb 女</span>\n\n<span class=\"token keyword\">delete</span> reuser<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>reuser<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> reuser<span class=\"token punctuation\">.</span>sex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//undefined 女</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span> sex<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//未命名 女</span>\n</code></pre>\n<p>&emsp;&emsp;接下来我们看看<code>toRef</code>和<code>toRefs</code>的具体实现：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 将proxy对象和目标的属性 转化为ref 并拥有默认值</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ObjectRefImpl<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> object<span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token keyword\">extends</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> __v_isRef <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">// 记录代理</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> _object<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 要辅助的key</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> _key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 默认值</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> _defaultValue<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 获取value</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> val <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_object<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> val <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_defaultValue <span class=\"token keyword\">as</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> val<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">set</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>newVal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_object<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newVal<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 将proxy对象和目标的属性 转化为ref 并拥有默认值</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">toRef</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> object<span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token keyword\">extends</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  object<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  key<span class=\"token operator\">:</span> <span class=\"token constant\">K</span><span class=\"token punctuation\">,</span>\n  defaultValue<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ToRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token constant\">K</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> val <span class=\"token operator\">=</span> object<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">isRef</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">?</span> val\n    <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectRefImpl</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> defaultValue<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 将proxy对象所有属性转化为ref值</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">toRefs</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> object<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>object<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ToRefs<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 只有内部代理才能toRefs</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__ <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">isProxy</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span>\n      <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">toRefs() expects a reactive object but received a plain one.</span><span class=\"token template-punctuation string\">`</span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 分别对所有属性toRef</span>\n  <span class=\"token keyword\">const</span> ret<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token operator\">=</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token builtin\">Array</span></span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ret<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">toRef</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>toRef</code>会先查看<code>proxy[key]</code>是否是<code>ref</code>如果是的话直接返回，如果不是则创建<code>ObjectRefImpl</code>并且将参数传入，<code>ObjectRefImpl</code>会标识当前对象是<code>ref</code>类型 <em>（通过<code>__v_isRef</code>属性）</em> ，并且缓存<code>proxy</code>、<code>key</code>和默认值。<code>get value</code>时直接通过<code>proxy[key]</code>来获取并返回，如果回去的值是<code>undefined</code>则使用默认值。<code>set value</code>时则通过<code>proxy[key] = newVal</code>来设置。</p>\n<p>&emsp;&emsp;<code>toRefs</code>则是将每个属性都调用一次没有默认值的<code>toRef</code>，并且返回与<code>proxy</code>一致的数据结构。</p>\n<p>&emsp;&emsp;为什么这里的<code>ObjectRefImpl</code>类不需要<code>dep</code>属性和收集依赖和触发更改呢？这是因为<code>_object</code>属性本身是<code>proxy</code>类型，当我们在使用<code>proxy[key]</code>就实现了收集依赖，在<code>proxy[key] = newVal</code>是就触发了更改。</p>\n<h2 id=\"其他辅助方法\">其他辅助方法</h2>\n<p>&emsp;&emsp;<code>ref</code>文件中还声明了其他辅助方法，比如<code>triggerRef</code>手动触发<code>ref</code>的更改使关联的<code>effect</code>重新执行收集函数；<code>unref</code>获取<code>ref</code>的原始值。这两个方法比较简单直接看源码即可，这里就不再讲解了。</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 手动触发 ref</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">triggerRef</span><span class=\"token punctuation\">(</span>ref<span class=\"token operator\">:</span> Ref<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 开发环境用当前值做最新值变化</span>\n  <span class=\"token function\">triggerRefValue</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">,</span> __DEV__ <span class=\"token operator\">?</span> ref<span class=\"token punctuation\">.</span>value <span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 解构ref，直接返回value</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">unref</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>ref<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> Ref<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">isRef</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span>value <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> ref<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;还有一个辅助方法<code>proxyRefs</code>，这个方法将一个对象直属属性内的所有<code>ref</code>属性值解构访问 <em>（不需要通过<code>value</code>下标访问）</em> 。什么是直属属性就是第一层属性，比如下方的代码：</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bill\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> unUser <span class=\"token operator\">=</span> <span class=\"token function\">proxyRefs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> name<span class=\"token punctuation\">,</span>\n  adderss<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    city<span class=\"token operator\">:</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"珠海\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>unUser<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// bill</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>unUser<span class=\"token punctuation\">.</span>address<span class=\"token punctuation\">.</span>city<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ref</span>\n\nunUser<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"lzb\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>unUser<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// lzb</span>\n</code></pre>\n<!-- `vue`组件之间传递参数的`props`就是通过这个函数来处理的，所以在父级中使用`ref` -->\n\n<p><code>proxyRefs</code>只对第一层属性的<code>ref</code>解构。我们看看它的源码：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 浅解构ref处理器</span>\n<span class=\"token keyword\">const</span> shallowUnwrapHandlers<span class=\"token operator\">:</span> ProxyHandler<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// getter将unref方便访问</span>\n  <span class=\"token function-variable function\">get</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">unref</span><span class=\"token punctuation\">(</span>Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// setter先查看是否是ref，如果是则更新value</span>\n  <span class=\"token function-variable function\">set</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> oldValue <span class=\"token operator\">=</span> target<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 如果新数据不是ref但旧数据是则更新value</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isRef</span><span class=\"token punctuation\">(</span>oldValue<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">isRef</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      oldValue<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 创建代理ref 解构方便使用</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">proxyRefs</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> object<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  objectWithRefs<span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ShallowUnwrapRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 如果是reactive对象则无需解构</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">isReactive</span><span class=\"token punctuation\">(</span>objectWithRefs<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">?</span> objectWithRefs\n    <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>objectWithRefs<span class=\"token punctuation\">,</span> shallowUnwrapHandlers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;当<code>proxyRefs</code>入参是<code>reactive</code>对象时则直接返回，<code>reactive</code>对象本身会对<code>ref</code>解构，而且是深度的，这里就不需要处理。<strong>有个特殊情况<code>shallowReactive</code>对象不会对<code>ref</code>解构，但是也直接返回了，也就是说这个方法对<code>shallowReactive</code>对象时无效的！</strong></p>\n<p>&emsp;&emsp;如果<code>proxyRefs</code>入参不是<code>reactive</code>对象，则创建代理，<code>get</code>拦截器通过<code>unref</code>来获取值返回，<code>set</code>拦截器通过判断当前要更新的是否是<code>ref</code>如果是则更新<code>value</code>。</p>\n<p>&emsp;&emsp;到这里我们<code>ref</code>的所有内容就已经讲完了，接下来日常小结。</p>\n<h2 id=\"小结\">小结</h2>\n<ul>\n<li><strong><code>ref</code>对象自身附加了<code>dep</code>，在收集依赖时通过<code>trackEffects</code>函数，触发时通过<code>triggerEffects</code>函数</strong></li>\n<li><strong><code>ref</code>能够创建深度响应式是依赖了<code>reactive</code></strong></li>\n<li><strong><code>Proxy</code>代理对象可以通过<code>toRef</code>和<code>toRefs</code>辅助方法保持对单个属性的引用，赋值修改会映射到<code>Proxy</code></strong></li>\n<li><strong><code>customRef</code>函数可以创建自由度极高的响应式对象</strong></li>\n</ul>\n<p>上一章：<a href=\"https://bill-lai.github.io/article/37495e00ab36e870f8dd\">vue3-effect 源码解析</a><br>下一章：<a href=\"https://bill-lai.github.io/article/b9bbb26eba4dacdc2312\">vue3-computed 源码解析</a></p>\n","desc":"阅读准备\n\n本文使用的vue版本为3.2.26。在阅读 ref 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 API了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。\n\n  我们前两章讲讲解了reactive 源码解析和effect 源码解析，并且知道了它们是如何"}}</script><script>!function(e){function t(t){for(var n,o,i=t[0],c=t[1],l=t[2],s=0,p=[];s<i.length;s++)o=i[s],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&p.push(a[o][0]),a[o]=0;for(n in c)Object.prototype.hasOwnProperty.call(c,n)&&(e[n]=c[n]);for(f&&f(t);p.length;)p.shift()();return u.push.apply(u,l||[]),r()}function r(){for(var e,t=0;t<u.length;t++){for(var r=u[t],n=!0,o=1;o<r.length;o++){var c=r[o];0!==a[c]&&(n=!1)}n&&(u.splice(t--,1),e=i(i.s=r[0]))}return e}var n={},o={1:0},a={1:0},u=[];function i(t){if(n[t])return n[t].exports;var r=n[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.e=function(e){var t=[];o[e]?t.push(o[e]):0!==o[e]&&{4:1}[e]&&t.push(o[e]=new Promise((function(t,r){for(var n="static/css/"+({}[e]||e)+"."+{3:"31d6cfe0",4:"4422e775"}[e]+".chunk.css",a=i.p+n,u=document.getElementsByTagName("link"),c=0;c<u.length;c++){var l=(f=u[c]).getAttribute("data-href")||f.getAttribute("href");if("stylesheet"===f.rel&&(l===n||l===a))return t()}var s=document.getElementsByTagName("style");for(c=0;c<s.length;c++){var f;if((l=(f=s[c]).getAttribute("data-href"))===n||l===a)return t()}var p=document.createElement("link");p.rel="stylesheet",p.type="text/css",p.onload=t,p.onerror=function(t){var n=t&&t.target&&t.target.src||a,u=new Error("Loading CSS chunk "+e+" failed.\n("+n+")");u.code="CSS_CHUNK_LOAD_FAILED",u.request=n,delete o[e],p.parentNode.removeChild(p),r(u)},p.href=a,document.getElementsByTagName("head")[0].appendChild(p)})).then((function(){o[e]=0})));var r=a[e];if(0!==r)if(r)t.push(r[2]);else{var n=new Promise((function(t,n){r=a[e]=[t,n]}));t.push(r[2]=n);var u,c=document.createElement("script");c.charset="utf-8",c.timeout=120,i.nc&&c.setAttribute("nonce",i.nc),c.src=function(e){return i.p+"static/js/"+({}[e]||e)+"."+{3:"c6f781a0",4:"199baeb9"}[e]+".chunk.js"}(e);var l=new Error;u=function(t){c.onerror=c.onload=null,clearTimeout(s);var r=a[e];if(0!==r){if(r){var n=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;l.message="Loading chunk "+e+" failed.\n("+n+": "+o+")",l.name="ChunkLoadError",l.type=n,l.request=o,r[1](l)}a[e]=void 0}};var s=setTimeout((function(){u({type:"timeout",target:c})}),12e4);c.onerror=c.onload=u,document.head.appendChild(c)}return Promise.all(t)},i.m=e,i.c=n,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/",i.oe=function(e){throw console.error(e),e};var c=this.webpackJsonpsource=this.webpackJsonpsource||[],l=c.push.bind(c);c.push=t,c=c.slice();for(var s=0;s<c.length;s++)t(c[s]);var f=l;r()}([])</script><script src="/static/js/2.b25e0f2c.chunk.js"></script><script src="/static/js/main.18e76180.chunk.js"></script></body></html>