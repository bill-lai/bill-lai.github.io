<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="theme-color" content="#000000"/><link rel="icon" href="/static/images/favicon.ico"/><link rel="apple-touch-icon" href="/static/images/logo192.png"/><link rel="stylesheet" href="/static/lib/simplemde.min.css"><title>vue3-computed源码解析 | bill-lai 的博客</title><link href="/static/css/main.0ca937d2.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="style_app__1yczT"><header class="style_slide__z5PNT style_slide__3Yi3e"><a href="/"><img src="/static/media/portrait.df7a5375.jpg" class="style_portrait__2GrBh" alt="portrait"/></a><div class="style_content__3GlZB"><div class="style_introduce__2UxnL"><h1><a href="/">bill-lai</a></h1><p>专注 WEB 端开发</p></div><ul class="style_navs__2yN9I"><li><a href="/">首页</a></li><li><a href="/archive">专题</a></li><li><a href="/special">归档</a></li></ul></div></header><div class="style_body__3Yz5T"><div class="style_layer__1ZQZt"><div class="style_main__XnHDF"><div> <h1 class="main-title">vue3-computed源码解析<span class="marker">2022-03-03 10:50</span></h1><div class="marked-body"><h2 id="阅读准备">阅读准备</h2>
<blockquote>
<p>本文使用的<code>vue</code>版本为<code>3.2.26</code>。在阅读 <code>computed</code> 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 <code>API</code>了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。</p>
</blockquote>
<p>&emsp;&emsp;在<code>vue3</code>中可以使用用户自定义的<code>getter</code>方法创建一个计算对象，计算对象通过<code>.value</code>来获取计算值。计算对象分为两种分别是<code>computed</code>和<code>deferredComputed</code>函数创建的。通过文档和单例可以知道<code>computed</code>和<code>deferredComputed</code>有以下特性：</p>
<ul>
<li><code>computed</code>的<code>getter</code>函数是懒加载的，在获取<code>value</code>时才会调用<code>getter</code>函数。</li>
<li><code>computed</code>会缓存上一次的<code>value</code>，当重复获取时，直接返回缓存值，只有依赖数据发生变化才会重新执行。</li>
<li><code>computed</code>返回的对象中有<code>effect</code>属性，可以调用<code>stop(computed.effect)</code>方法可以停止<code>computed</code>的监听。</li>
<li><code>computed</code>可以传入<code>setter</code>函数，当对<code>computed.value</code>更改时会调用这个函数</li>
<li>在<code>effect</code>监听函数中使用<code>deferredComputed</code>对象时，<code>deferredComputed</code>对象的<code>value</code>发生变化时，不会立即触发<code>effect</code>监听函数，而是在下一次微任务 <em><code>（Promise.then）</code></em> 触发.</li>
<li>当直接获取<code>deferredComputed</code>对象的<code>value</code>时，会直接拿到最新值，不会等待下一次微任务.</li>
</ul>
<p>&emsp;&emsp;在<code>vue3</code>中<code>computed</code>也是属于一种<code>ref</code>类型，当使用<code>isRef</code>函数执行时会返回<code>true</code>。通过上一章<a href="https://bill-lai.github.io/article/4838fc56a04f95936f16">vue3-ref源码解析</a>我们知道，在<code>ref</code>类型能响应式的关键就是存储自身的<code>dep</code>，在获取时调用<code>trackRefValue</code>函数，在更改时调用<code>triggerRefValue</code>函数。</p>
<p>&emsp;&emsp;而只读版本的<code>computed</code>是不会直接通过<code>value</code>属性来更改的，它是通过传入的<code>getter</code>函数里面的依赖发生更改时重新执行的<code>getter</code>函数来实现的。更改依赖就重新执行，这个是不是很熟悉，没错他就是<code>effect</code>的特性，不了解的同学可以通过<a href="https://bill-lai.github.io/article/37495e00ab36e870f8dd">vue3-effect源码解析</a>看看。也就是说当依赖数据发生更改而引起<code>effect</code>重新执行监听函数时，我们就需要实现懒加载以及<code>triggerRefValue</code>函数的调用。</p>
<p>&emsp;&emsp;下面我们一起来看看<code>vue</code>中是如何实现的，</p>
<h2 id="computed">computed</h2>
<p>&emsp;&emsp;首先我们看看<code>computed</code>函数的实现：</p>
<pre><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> isFunction <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> val <span class="token keyword">is</span> <span class="token builtin">Function</span> <span class="token operator">=></span>
  <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'function'</span>

<span class="token comment">// 创建计算属性ref</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">computed</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
  getterOrOptions<span class="token operator">:</span> ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> WritableComputedOptions<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span>
  debugOptions<span class="token operator">?</span><span class="token operator">:</span> DebuggerOptions
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> getter<span class="token operator">:</span> ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span>
  <span class="token keyword">let</span> setter<span class="token operator">:</span> ComputedSetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span>

  <span class="token comment">// 是否只有getter</span>
  <span class="token keyword">const</span> onlyGetter <span class="token operator">=</span> <span class="token function">isFunction</span><span class="token punctuation">(</span>getterOrOptions<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>onlyGetter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> getterOrOptions
    <span class="token comment">// 如果只有getter，在开发环境下吧setter换成警告</span>
    setter <span class="token operator">=</span> __DEV__
      <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'Write operation failed: computed value is readonly'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token operator">:</span> <span class="token constant">NOOP</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    getter <span class="token operator">=</span> getterOrOptions<span class="token punctuation">.</span>get
    setter <span class="token operator">=</span> getterOrOptions<span class="token punctuation">.</span>set
  <span class="token punctuation">}</span>

  <span class="token comment">// 传入 getter、setter、是否有setter 创建computed对象</span>
  <span class="token keyword">const</span> cRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComputedRefImpl</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> setter<span class="token punctuation">,</span> onlyGetter <span class="token operator">||</span> <span class="token operator">!</span>setter<span class="token punctuation">)</span>

  <span class="token comment">// 如果是开发环境在effect对象注入传入的收集和触发钩子</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">&amp;&amp;</span> debugOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cRef<span class="token punctuation">.</span>effect<span class="token punctuation">.</span>onTrack <span class="token operator">=</span> debugOptions<span class="token punctuation">.</span>onTrack
    cRef<span class="token punctuation">.</span>effect<span class="token punctuation">.</span>onTrigger <span class="token operator">=</span> debugOptions<span class="token punctuation">.</span>onTrigger
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> cRef <span class="token keyword">as</span> <span class="token builtin">any</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>computed</code>的第一个参数是一个<code>getter</code>函数或者是包含<code>get</code>和<code>set</code>属性的对象，当只有<code>getter</code>时会给一个默认的<code>setter</code>。然后根据<code>getter</code>、<code>setter</code>和是否有<code>setter</code>创建<code>ComputedRefImpl</code>对象，并将用户传入的测试参数收集钩子和触发钩子附加到<code>computed</code>对象的<code>effect</code>属性上。入口函数还是比较简单的，简单的一些判断和附加，我们接下来看看<code>ComputedRefImpl</code>类的具体实现：</p>
<pre><code class="language-ts"><span class="token comment">// Computed对象</span>
<span class="token keyword">class</span> <span class="token class-name">ComputedRefImpl<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token comment">// 引用了当前computed的effect的Set</span>
  <span class="token keyword">public</span> dep<span class="token operator">?</span><span class="token operator">:</span> Dep <span class="token operator">=</span> <span class="token keyword">undefined</span>

  <span class="token comment">// 放置缓存值</span>
  <span class="token keyword">private</span> _value<span class="token operator">!</span><span class="token operator">:</span> <span class="token constant">T</span>
  <span class="token comment">// 当前值是否是脏数据，（当前值需要更新）</span>
  <span class="token keyword">private</span> _dirty <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// 放置effect对象</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> effect<span class="token operator">:</span> ReactiveEffect<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span>

  <span class="token comment">// ref标识</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> __v_isRef <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// isReadonly标识</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span>ReactiveFlags<span class="token punctuation">.</span><span class="token constant">IS_READONLY</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span>
    getter<span class="token operator">:</span> ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> _setter<span class="token operator">:</span> ComputedSetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span>
    isReadonly<span class="token operator">:</span> <span class="token builtin">boolean</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建effect对象，将当前getter当做监听函数，并附加调度器</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>effect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveEffect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果当前不是脏数据</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>_dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前为脏数据</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_dirty <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token comment">// 触发更改</span>
        <span class="token function">triggerRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 根据传入是否有setter函数来决定是否只读</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>ReactiveFlags<span class="token punctuation">.</span><span class="token constant">IS_READONLY</span><span class="token punctuation">]</span> <span class="token operator">=</span> isReadonly
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// readonly(computed)，获取时this就是readonly，无法修改属性, 所以要先获取原始对象</span>
    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token function">toRaw</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token comment">// 收集依赖</span>
    <span class="token function">trackRefValue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
    <span class="token comment">// 如果当前是脏数据（没更新）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>_dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 更改为不是脏数据</span>
      self<span class="token punctuation">.</span>_dirty <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token comment">// 执行收集函数，更新缓存</span>
      self<span class="token punctuation">.</span>_value <span class="token operator">=</span> self<span class="token punctuation">.</span>effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果不是脏数据则直接获取缓存值</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_value
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>newValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_setter</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>ComputedRefImpl</code>对象是通过<code>_value</code>和<code>_dirty</code>属性来实现懒加载的。<code>_value</code>放置缓存的<code>value</code>，<code>_dirty</code>标识当前是否是脏数据 <em>（需要更新）</em>。当用户获取<code>computed.value</code>时，如果不是脏数据则直接返回缓存的<code>value</code>，如果是脏数据则调用<code>getter</code>来获取最新的<code>value</code>缓存起来，并更改为不是脏数据。</p>
<p>&emsp;&emsp;构建<code>ComputedRefImpl</code>对象时会创建一个以<code>getter</code>为监听函数的<code>effect</code>对象，并注入调度器，下面我们简称为<code>ceffect</code>。当<code>ceffect</code>的依赖数据更改触发需要重新收集时，并不会马上执行收集函数，而是执行<code>computed</code>的调度器 <em>（<a href="https://bill-lai.github.io/article/37495e00ab36e870f8dd#effect">vue-effect源码解析</a>讲过）</em>。</p>
<p>&emsp;&emsp;当<code>computed</code>的调度器被执行时，说明<code>getter</code>里面的依赖数据发生更改，此时<code>computed.value</code>也可能更改，而<code>computed</code>又是懒加载的，我们不能直接执行依赖函数查看是否真正修改了，这样会失去懒加载特性，所以我们就认为它被修改了。</p>
<p>&emsp;&emsp;也就是说调度器被执行了就是更改了<code>computed</code>，这时候需要更改为脏数据并且执行<code>triggerRefValue</code>函数。</p>
<p>&emsp;&emsp;<code>get value</code>就比较简单了，判断是否是脏数据，如果是则获更改脏数据状态，执行收集并获取返回值做为最新的<code>value</code>，并返回。</p>
<h3 id="注意">注意</h3>
<p>&emsp;&emsp;我们看到调度器还有一条判断，如果当前已经是脏数据了，则不会重新更改和调用<code>triggerRefValue</code>，大部分情况如果是脏数据说明已经<code>triggerRefValue</code>过了，当前还未获取过<code>computed.value</code>所以不需要再次<code>triggerRefValue</code>是合理的。但是有些情况会执行不正确，大家看看这段代码：</p>
<pre><code class="language-ts"><span class="token keyword">const</span> reuser <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'bill'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> welcome <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'hello '</span> <span class="token operator">+</span> reuser<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token comment">// teffect</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>welcome<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  reuser<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'lzb'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

reuser<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'123'</span>

<span class="token comment">// hello bill</span>
</code></pre>
<p>&emsp;&emsp;实际上只会打印一次<code>hello bill</code>，让我们来理一理发生了什么</p>
<ul>
<li>入栈<code>teffect</code>对象，执行<code>teffect</code>依赖函数</li>
<li>执行时遇到<code>welcome.value</code>，执行<code>ceffect.run()</code>，入栈<code>ceffect</code>，并收集到<code>reuser.name</code>依赖，<code>ceffect</code>出栈</li>
<li>执行到<code>reuser.name = &#39;lzb&#39;</code>，<code>reuser.name</code>的修改会触发<code>welcome</code>调度器的重新执行，将修改为脏数据并触发关联的<code>teffect</code>重新执行</li>
<li><code>teffect</code>在<code>effectStack</code>栈内，重新执行将什么都不干， <code>teffect</code>依赖函数执行完毕，<code>teffect</code>出栈</li>
<li>执行<code>reuser.name = &#39;123&#39;</code>，<code>reuser.name</code>的修改会触发<code>welcome</code>调度器的重新执行，因为是脏数据所以什么都不干执行完毕</li>
</ul>
<p>&emsp;&emsp;大家看到， <strong>当<code>effect</code>收集函数内先依赖<code>computed</code>，并修改<code>computed</code>依赖的数据时，在<code>effect</code>外修改<code>computed</code>可能会导致<code>effect</code>无法正常响应。</strong> 这个不知道是bug还是处于什么考虑。</p>
<h2 id="deferredcomputed">deferredComputed</h2>
<p>&emsp;&emsp;<code>deferredComputed</code>是在<code>effect</code>中使用时有异步的特性，当<code>effect</code>收集到<code>deferredComputed</code>依赖，<code>deferredComputed</code>的<code>value</code>发生变化并不会马上触发<code>effect</code>收集函数，而是等到下一次微任务执行。当直接获取<code>deferredComputed.value</code>时是同步执行的，会马上获取到最新值。</p>
<p>&emsp;&emsp;<code>deferredComputed</code>也有懒加载的特性，也就是说也是根据自定义<code>effect</code>调度器实现的。当数据改变执行<code>triggerRefValue</code>来触发其他依赖了自身的<code>effect</code>收集函数的重新执行。也就是说当<code>deferredComputed</code>数据发生改变在下一次微任务执行<code>triggerRefValue</code>即可实现在<code>effect</code>中异步的特性。</p>
<p>&emsp;&emsp;由于<code>deferredComputed</code>的调度器逻辑相对比较复杂，我们从拆开讲解，下面我们看看删减源码：</p>
<pre><code class="language-ts"><span class="token comment">// 异步computed类</span>
<span class="token keyword">class</span> <span class="token class-name">DeferredComputedRefImpl<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> dep<span class="token operator">?</span><span class="token operator">:</span> Dep <span class="token operator">=</span> <span class="token keyword">undefined</span>

  <span class="token keyword">private</span> _value<span class="token operator">!</span><span class="token operator">:</span> <span class="token constant">T</span>
  <span class="token keyword">private</span> _dirty <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> effect<span class="token operator">:</span> ReactiveEffect<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span>

  <span class="token keyword">public</span> <span class="token keyword">readonly</span> __v_isRef <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token keyword">public</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span>ReactiveFlags<span class="token punctuation">.</span><span class="token constant">IS_READONLY</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span>getter<span class="token operator">:</span> ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> scheduled <span class="token operator">=</span> <span class="token boolean">false</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>effect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveEffect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token comment">// 被effect 引用有dep才需要延迟</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>scheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 获取比对值，决定是否执行 triggerRefValue</span>
          <span class="token keyword">const</span> valueToCompare <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_value
          <span class="token comment">// 标识正在等待</span>
          scheduled <span class="token operator">=</span> <span class="token boolean">true</span>

          <span class="token comment">// 下一次微任务执行</span>
          <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果当前computed没有停用</span>
            <span class="token comment">// 并且主动获取值，查看比对值是否一直</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>effect<span class="token punctuation">.</span>active <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> valueToCompare<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">triggerRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 没有再等待冲刷</span>
            scheduled <span class="token operator">=</span> <span class="token boolean">false</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_dirty <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token function">_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_dirty <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token comment">// 执行effect获取返回值</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_value
  <span class="token punctuation">}</span>

  <span class="token comment">// 获取值，主动获取一定能刷新值</span>
  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">trackRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">toRaw</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">deferredComputed</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">getter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> ComputedRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DeferredComputedRefImpl</span><span class="token punctuation">(</span>getter<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">any</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>deferredComputed</code>大部分属性都跟<code>computed</code>差不多，不同的是调度器的定义，在获取<code>value</code>时将<code>trackRefValue</code>与值处理分离开来。</p>
<p>&emsp;&emsp;首先我们看到调度器的处理，如果当前<code>deferredComputed</code>没有收集到依赖，也就是没有在<code>effect</code>中使用，那么就直接修改为脏数据即可，因为异步特性是针对<code>effect</code>的监听函数的。除此之外<code>deferredComputed</code>还会防抖，一次微任务中多次调度只会执行一次，使用<code>scheduled</code>变量来完成这一特性，在进入前记录当前<code>deferredComputed</code>正在执行任务，执行完毕后会恢复状态，当多次进入时会判断如果正在执行任务则直接忽略。最后在下一次微任务后如果值被修改则<code>triggerRefValue</code>，触发当前<code>deferredComputed</code>值被修改使得被引用的<code>effect</code>被重新执行。</p>
<p>&emsp;&emsp;接下来我们看看<code>scheduler</code>函数中的具体实现细节：</p>
<pre><code class="language-ts"><span class="token comment">// 微任务</span>
<span class="token keyword">const</span> tick <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queue<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// 正在执行任务</span>
<span class="token keyword">let</span> queued <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token comment">// 任务调度器</span>
<span class="token keyword">const</span> <span class="token function-variable function">scheduler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  <span class="token comment">// 如果正在执行任务仅添加到任务中即可</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有执行任务标识正在执行，然后再下一次微任务中执行</span>
    queued <span class="token operator">=</span> <span class="token boolean">true</span>
    tick<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flush<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 冲刷，执行任务</span>
<span class="token keyword">const</span> <span class="token function-variable function">flush</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取所有任务，然后执行</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 清空</span>
  queue<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
  queued <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>scheduler</code>中是使用<code>promise.then</code>来实现异步的，当任务进入时会存入到队列中。如果当前是队列首次执行，则在下一次微任务调用<code>flush</code>方法。<code>flush</code>中按顺序执行任务队列的所有方法，然后恢复状态。</p>
<p>&emsp;&emsp;在任务执行期间，加入的任务始终会在下一次微任务一起执行，即使实在任务中加入任务，比如下方这段代码</p>
<pre><code class="language-ts"><span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
  <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>&emsp;&emsp;让我们回到<code>deferredComputed</code>，综合<code>scheduler</code>，也就是说，所有的更改会在一次微任务中按顺序执行。</p>
<p>&emsp;&emsp;现在<code>deferredComputed</code>主要代码我们已经看完了，但是还有一些情况需要处理。我们看到上面<code>DeferredComputedRefImpl</code>源码实现中，只有当<code>valueToCompare</code>发生变化时才会调用<code>triggerRefValue</code>，通知依赖了当前<code>computed</code>的<code>effect</code>重新执行。</p>
<p>&emsp;&emsp;<code>valueToCompare</code>是在执行微任务前缓存下来的，当不存在<code>dcEffect</code>依赖<code>deferredComputed</code>时是没问题的，因为会缓存<code>_value</code>，即使用户主动获取了<code>computed.value</code>改变了<code>this._value</code>，在下一次微任务比对的也是缓存的<code>_value</code>。</p>
<p>&emsp;&emsp;当存在<code>dcEffect</code>依赖<code>deferredComputed</code>时就会出问题，比如存在<code>dc1</code>和<code>dc2</code>，<code>dc2</code>的值依赖<code>dc1</code>，而<code>dc1</code>只有一下次微任务才会执行<code>triggerRefValue</code>通知<code>dc2</code>调度器。所以<code>dc2</code>在下一次微任务时才会获取<code>valueToCompare</code>来比对决定是否执行<code>triggerRefValue</code>。假如用户通过<code>dc2.value</code>来强行刷新值的话，<code>_value</code>就会存储最新的值，在下一次微任务时拿到的<code>valueToCompare</code>会与<code>dc2.value</code>一样，就会导致<code>dc2</code>无法执行<code>triggerRefValue</code>，依赖了<code>dc2</code>的<code>effect</code>无法正常执行，比如下方代码：</p>
<pre><code class="language-ts"><span class="token keyword">const</span> src <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> c1 <span class="token operator">=</span> <span class="token function">deferredComputed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> src<span class="token punctuation">.</span>value <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> c2 <span class="token operator">=</span> <span class="token function">deferredComputed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> c1<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  count<span class="token operator">++</span>
  <span class="token keyword">return</span> c2<span class="token punctuation">.</span>value
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>

src<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// 刷新c2，c2的_value是最新值</span>
c2<span class="token punctuation">.</span>value

<span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// c2 拿到的valueToCompare与this._get()值一致，无法发送triggerRefValue</span>
  <span class="token comment">// 1 </span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>&emsp;&emsp;其实解决方案也很简单，只需要在<code>deferredComputed</code>发生更改时，获取所有关联的<code>dceffect</code>，并让他们缓存当前<code>_value</code>*(<code>valueToCompare</code>)*，确保能正确的比对，我们看看<code>vue</code>是如何处理的：</p>
<pre><code class="language-diff-ts"><span class="token keyword">class</span> <span class="token class-name">DeferredComputedRefImpl<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>getter<span class="token operator">:</span> ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 比较目标</span>
<span class="inserted">   <span class="content"><span class="token keyword">let</span> compareTarget<span class="token operator">:</span> <span class="token builtin">any</span></span></span>
    <span class="token comment">// 是否需要比较目标比较</span>
<span class="inserted">   <span class="content"><span class="token keyword">let</span> hasCompareTarget <span class="token operator">=</span> <span class="token boolean">false</span></span></span>
    <span class="token keyword">let</span> scheduled <span class="token operator">=</span> <span class="token boolean">false</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>effect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveEffect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">(</span>computedTrigger<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果是deferredComputed引起的调度</span>
<span class="inserted">       <span class="content"><span class="token keyword">if</span> <span class="token punctuation">(</span>computedTrigger<span class="token punctuation">)</span> <span class="token punctuation">{</span></span></span>
<span class="inserted">         <span class="content"><span class="token comment">// 获取当前比对值，防止出现拿最新的不触发trigger的情感</span></span></span>
<span class="inserted">         <span class="content"><span class="token comment">// 如果不缓存值，当上一个缓冲区刷新之后，获取当前的都是最新值，则不会触发trigger</span></span></span>
<span class="inserted">         <span class="content">compareTarget <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_value</span></span>
<span class="inserted">         <span class="content">hasCompareTarget <span class="token operator">=</span> <span class="token boolean">true</span></span></span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>scheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 获取比对之</span>
<span class="inserted">         <span class="content"><span class="token keyword">const</span> valueToCompare <span class="token operator">=</span> hasCompareTarget <span class="token operator">?</span> compareTarget <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_value</span></span>
          <span class="token comment">// 标识正在等待</span>
          scheduled <span class="token operator">=</span> <span class="token boolean">true</span>
          <span class="token comment">// 恢复hasCompareTarget</span>
<span class="inserted">         <span class="content">hasCompareTarget <span class="token operator">=</span> <span class="token boolean">false</span></span></span>

          <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>effect<span class="token punctuation">.</span>active <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> valueToCompare<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">triggerRefValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            scheduled <span class="token operator">=</span> <span class="token boolean">false</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 获取当前关联的deferredComputed依次触发调度器，并传入是computed触发标识</span>
<span class="inserted">       <span class="content"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> e <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span></span></span>
<span class="inserted">         <span class="content"><span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token punctuation">{</span></span></span>
<span class="inserted">           <span class="content">e<span class="token punctuation">.</span>scheduler<span class="token operator">!</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token comment">/* computedTrigger */</span><span class="token punctuation">)</span></span></span>
<span class="inserted">         <span class="content"><span class="token punctuation">}</span></span></span>
<span class="inserted">       <span class="content"><span class="token punctuation">}</span></span></span>
<span class="inserted">     <span class="content"><span class="token punctuation">}</span></span></span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_dirty <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 标识当前effect是deferredComputed</span>
<span class="inserted">   <span class="content"><span class="token keyword">this</span><span class="token punctuation">.</span>effect<span class="token punctuation">.</span>computed <span class="token operator">=</span> <span class="token boolean">true</span></span></span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>dcEffect</code>会在附加<code>computed</code>属性设置为<code>true</code>，来标识当前<code>effect</code>属于<code>deferredComputed</code>。当<code>deferredComputed</code>值被修改引起调度器重新执行时，会获取所有关联的<code>dcEffect</code>，然后逐一执行他们的调度器，并注明执行是来源于<code>deferredComputed</code>。</p>
<p>&emsp;&emsp;如果调度器是<code>deferredComputed</code>执行的，那么就需要缓存当前<code>_value</code>，确保能正确对比。<code>vue</code>中使用<code>hasCompareTarget</code>变量来标识是需要使用缓存值来比对还是直接使用<code>_value</code>来比对。当前<code>deferredComputed</code>又可能被其他<code>deferredComputed</code>依赖，也需要对被关联<code>deferredComputed</code>通知缓存<code>value</code>。这样就能处理这种情况了。</p>
<p>&emsp;&emsp;到这里<code>computed</code>的具体实现了就已经看完了，完结撒花。</p>
<p>上一章：<a href="https://bill-lai.github.io/article/4838fc56a04f95936f16">vue3-ref源码解析</a></p>
</div><div class="style_article-loading-layer__3poja"><div class="style_layer__GxMiF"><div style="fill:var(--vice-color);height:64px;width:64px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle transform="translate(8 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(16 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.3"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(24 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.6"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
</svg>
</div></div></div> </div><div class="style_bottom__29qYA"><p>©2021 - bill-lai 的小站 -<a rel="noreferrer" href="https://github.com/bill-lai/bill-lai.github.io" target="_blank">站点源码</a></p><p>本站使用<a rel="noreferrer" target="_blank" href="https://react.docschina.org/docs/hooks-reference.html#usememo">ReactHook</a><a rel="noreferrer" target="_blank" href="https://www.typescriptlang.org/zh/">TypeScript</a><a rel="noreferrer" target="_blank" href="https://docs.github.com/cn/rest">githubAPI</a><a rel="noreferrer" target="_blank" href="https://simplemde.com/">SimpleMDE</a>制作</p></div></div><div class="style_right-layer__Rm9TS "><div class="style_right__3hdcL"><div class="style_right-content__F68mu"><div class="navigation"><h4 class="style_title__1aA1F">目录列表</h4><ul class="style_top-navs__3vyAr"><li class=""><span>阅读准备<!-- --> </span></li><li class=""><span>computed<!-- --> <i class="iconfont icon-arrow_down"></i></span><ul class="style_child-navs__6paad"><li class=""><span>注意<!-- --> </span></li></ul></li><li class=""><span>deferredComputed<!-- --> </span></li></ul></div></div></div></div></div></div></div></div>
          <script>var globalState = {"article/b9bbb26eba4dacdc2312":{"title":"vue3-computed源码解析","id":"b9bbb26eba4dacdc2312","mtime":1646275858685,"ctime":1646275630320,"issues":{"number":22,"commentsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/22/comments","reactionsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/22/reactions"},"head":null,"foot":null,"dirs":[{"leave":2,"title":"阅读准备","children":[]},{"leave":2,"title":"computed","children":[{"leave":3,"title":"注意","children":[]}]},{"leave":2,"title":"deferredComputed","children":[]}],"body":"<h2 id=\"阅读准备\">阅读准备</h2>\n<blockquote>\n<p>本文使用的<code>vue</code>版本为<code>3.2.26</code>。在阅读 <code>computed</code> 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 <code>API</code>了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。</p>\n</blockquote>\n<p>&emsp;&emsp;在<code>vue3</code>中可以使用用户自定义的<code>getter</code>方法创建一个计算对象，计算对象通过<code>.value</code>来获取计算值。计算对象分为两种分别是<code>computed</code>和<code>deferredComputed</code>函数创建的。通过文档和单例可以知道<code>computed</code>和<code>deferredComputed</code>有以下特性：</p>\n<ul>\n<li><code>computed</code>的<code>getter</code>函数是懒加载的，在获取<code>value</code>时才会调用<code>getter</code>函数。</li>\n<li><code>computed</code>会缓存上一次的<code>value</code>，当重复获取时，直接返回缓存值，只有依赖数据发生变化才会重新执行。</li>\n<li><code>computed</code>返回的对象中有<code>effect</code>属性，可以调用<code>stop(computed.effect)</code>方法可以停止<code>computed</code>的监听。</li>\n<li><code>computed</code>可以传入<code>setter</code>函数，当对<code>computed.value</code>更改时会调用这个函数</li>\n<li>在<code>effect</code>监听函数中使用<code>deferredComputed</code>对象时，<code>deferredComputed</code>对象的<code>value</code>发生变化时，不会立即触发<code>effect</code>监听函数，而是在下一次微任务 <em><code>（Promise.then）</code></em> 触发.</li>\n<li>当直接获取<code>deferredComputed</code>对象的<code>value</code>时，会直接拿到最新值，不会等待下一次微任务.</li>\n</ul>\n<p>&emsp;&emsp;在<code>vue3</code>中<code>computed</code>也是属于一种<code>ref</code>类型，当使用<code>isRef</code>函数执行时会返回<code>true</code>。通过上一章<a href=\"https://bill-lai.github.io/article/4838fc56a04f95936f16\">vue3-ref源码解析</a>我们知道，在<code>ref</code>类型能响应式的关键就是存储自身的<code>dep</code>，在获取时调用<code>trackRefValue</code>函数，在更改时调用<code>triggerRefValue</code>函数。</p>\n<p>&emsp;&emsp;而只读版本的<code>computed</code>是不会直接通过<code>value</code>属性来更改的，它是通过传入的<code>getter</code>函数里面的依赖发生更改时重新执行的<code>getter</code>函数来实现的。更改依赖就重新执行，这个是不是很熟悉，没错他就是<code>effect</code>的特性，不了解的同学可以通过<a href=\"https://bill-lai.github.io/article/37495e00ab36e870f8dd\">vue3-effect源码解析</a>看看。也就是说当依赖数据发生更改而引起<code>effect</code>重新执行监听函数时，我们就需要实现懒加载以及<code>triggerRefValue</code>函数的调用。</p>\n<p>&emsp;&emsp;下面我们一起来看看<code>vue</code>中是如何实现的，</p>\n<h2 id=\"computed\">computed</h2>\n<p>&emsp;&emsp;首先我们看看<code>computed</code>函数的实现：</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> isFunction <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> val <span class=\"token keyword\">is</span> <span class=\"token builtin\">Function</span> <span class=\"token operator\">=></span>\n  <span class=\"token keyword\">typeof</span> val <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span>\n\n<span class=\"token comment\">// 创建计算属性ref</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">computed</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  getterOrOptions<span class=\"token operator\">:</span> ComputedGetter<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> WritableComputedOptions<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  debugOptions<span class=\"token operator\">?</span><span class=\"token operator\">:</span> DebuggerOptions\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> getter<span class=\"token operator\">:</span> ComputedGetter<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span>\n  <span class=\"token keyword\">let</span> setter<span class=\"token operator\">:</span> ComputedSetter<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span>\n\n  <span class=\"token comment\">// 是否只有getter</span>\n  <span class=\"token keyword\">const</span> onlyGetter <span class=\"token operator\">=</span> <span class=\"token function\">isFunction</span><span class=\"token punctuation\">(</span>getterOrOptions<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>onlyGetter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    getter <span class=\"token operator\">=</span> getterOrOptions\n    <span class=\"token comment\">// 如果只有getter，在开发环境下吧setter换成警告</span>\n    setter <span class=\"token operator\">=</span> __DEV__\n      <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Write operation failed: computed value is readonly'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">:</span> <span class=\"token constant\">NOOP</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    getter <span class=\"token operator\">=</span> getterOrOptions<span class=\"token punctuation\">.</span>get\n    setter <span class=\"token operator\">=</span> getterOrOptions<span class=\"token punctuation\">.</span>set\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 传入 getter、setter、是否有setter 创建computed对象</span>\n  <span class=\"token keyword\">const</span> cRef <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ComputedRefImpl</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">,</span> setter<span class=\"token punctuation\">,</span> onlyGetter <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>setter<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 如果是开发环境在effect对象注入传入的收集和触发钩子</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__ <span class=\"token operator\">&amp;&amp;</span> debugOptions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cRef<span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span>onTrack <span class=\"token operator\">=</span> debugOptions<span class=\"token punctuation\">.</span>onTrack\n    cRef<span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span>onTrigger <span class=\"token operator\">=</span> debugOptions<span class=\"token punctuation\">.</span>onTrigger\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> cRef <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>computed</code>的第一个参数是一个<code>getter</code>函数或者是包含<code>get</code>和<code>set</code>属性的对象，当只有<code>getter</code>时会给一个默认的<code>setter</code>。然后根据<code>getter</code>、<code>setter</code>和是否有<code>setter</code>创建<code>ComputedRefImpl</code>对象，并将用户传入的测试参数收集钩子和触发钩子附加到<code>computed</code>对象的<code>effect</code>属性上。入口函数还是比较简单的，简单的一些判断和附加，我们接下来看看<code>ComputedRefImpl</code>类的具体实现：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// Computed对象</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ComputedRefImpl<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 引用了当前computed的effect的Set</span>\n  <span class=\"token keyword\">public</span> dep<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Dep <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span>\n\n  <span class=\"token comment\">// 放置缓存值</span>\n  <span class=\"token keyword\">private</span> _value<span class=\"token operator\">!</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n  <span class=\"token comment\">// 当前值是否是脏数据，（当前值需要更新）</span>\n  <span class=\"token keyword\">private</span> _dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token comment\">// 放置effect对象</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> effect<span class=\"token operator\">:</span> ReactiveEffect<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span>\n\n  <span class=\"token comment\">// ref标识</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> __v_isRef <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token comment\">// isReadonly标识</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> <span class=\"token punctuation\">[</span>ReactiveFlags<span class=\"token punctuation\">.</span><span class=\"token constant\">IS_READONLY</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    getter<span class=\"token operator\">:</span> ComputedGetter<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> _setter<span class=\"token operator\">:</span> ComputedSetter<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    isReadonly<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 创建effect对象，将当前getter当做监听函数，并附加调度器</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effect <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReactiveEffect</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 如果当前不是脏数据</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_dirty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 当前为脏数据</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        <span class=\"token comment\">// 触发更改</span>\n        <span class=\"token function\">triggerRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// 根据传入是否有setter函数来决定是否只读</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">[</span>ReactiveFlags<span class=\"token punctuation\">.</span><span class=\"token constant\">IS_READONLY</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> isReadonly\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// readonly(computed)，获取时this就是readonly，无法修改属性, 所以要先获取原始对象</span>\n    <span class=\"token keyword\">const</span> self <span class=\"token operator\">=</span> <span class=\"token function\">toRaw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 收集依赖</span>\n    <span class=\"token function\">trackRefValue</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 如果当前是脏数据（没更新）</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>_dirty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 更改为不是脏数据</span>\n      self<span class=\"token punctuation\">.</span>_dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      <span class=\"token comment\">// 执行收集函数，更新缓存</span>\n      self<span class=\"token punctuation\">.</span>_value <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 如果不是脏数据则直接获取缓存值</span>\n    <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>_value\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">set</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span>newValue<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_setter</span><span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>ComputedRefImpl</code>对象是通过<code>_value</code>和<code>_dirty</code>属性来实现懒加载的。<code>_value</code>放置缓存的<code>value</code>，<code>_dirty</code>标识当前是否是脏数据 <em>（需要更新）</em>。当用户获取<code>computed.value</code>时，如果不是脏数据则直接返回缓存的<code>value</code>，如果是脏数据则调用<code>getter</code>来获取最新的<code>value</code>缓存起来，并更改为不是脏数据。</p>\n<p>&emsp;&emsp;构建<code>ComputedRefImpl</code>对象时会创建一个以<code>getter</code>为监听函数的<code>effect</code>对象，并注入调度器，下面我们简称为<code>ceffect</code>。当<code>ceffect</code>的依赖数据更改触发需要重新收集时，并不会马上执行收集函数，而是执行<code>computed</code>的调度器 <em>（<a href=\"https://bill-lai.github.io/article/37495e00ab36e870f8dd#effect\">vue-effect源码解析</a>讲过）</em>。</p>\n<p>&emsp;&emsp;当<code>computed</code>的调度器被执行时，说明<code>getter</code>里面的依赖数据发生更改，此时<code>computed.value</code>也可能更改，而<code>computed</code>又是懒加载的，我们不能直接执行依赖函数查看是否真正修改了，这样会失去懒加载特性，所以我们就认为它被修改了。</p>\n<p>&emsp;&emsp;也就是说调度器被执行了就是更改了<code>computed</code>，这时候需要更改为脏数据并且执行<code>triggerRefValue</code>函数。</p>\n<p>&emsp;&emsp;<code>get value</code>就比较简单了，判断是否是脏数据，如果是则获更改脏数据状态，执行收集并获取返回值做为最新的<code>value</code>，并返回。</p>\n<h3 id=\"注意\">注意</h3>\n<p>&emsp;&emsp;我们看到调度器还有一条判断，如果当前已经是脏数据了，则不会重新更改和调用<code>triggerRefValue</code>，大部分情况如果是脏数据说明已经<code>triggerRefValue</code>过了，当前还未获取过<code>computed.value</code>所以不需要再次<code>triggerRefValue</code>是合理的。但是有些情况会执行不正确，大家看看这段代码：</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">const</span> reuser <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'bill'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> welcome <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">'hello '</span> <span class=\"token operator\">+</span> reuser<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// teffect</span>\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>welcome<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n  reuser<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'lzb'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nreuser<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'123'</span>\n\n<span class=\"token comment\">// hello bill</span>\n</code></pre>\n<p>&emsp;&emsp;实际上只会打印一次<code>hello bill</code>，让我们来理一理发生了什么</p>\n<ul>\n<li>入栈<code>teffect</code>对象，执行<code>teffect</code>依赖函数</li>\n<li>执行时遇到<code>welcome.value</code>，执行<code>ceffect.run()</code>，入栈<code>ceffect</code>，并收集到<code>reuser.name</code>依赖，<code>ceffect</code>出栈</li>\n<li>执行到<code>reuser.name = &#39;lzb&#39;</code>，<code>reuser.name</code>的修改会触发<code>welcome</code>调度器的重新执行，将修改为脏数据并触发关联的<code>teffect</code>重新执行</li>\n<li><code>teffect</code>在<code>effectStack</code>栈内，重新执行将什么都不干， <code>teffect</code>依赖函数执行完毕，<code>teffect</code>出栈</li>\n<li>执行<code>reuser.name = &#39;123&#39;</code>，<code>reuser.name</code>的修改会触发<code>welcome</code>调度器的重新执行，因为是脏数据所以什么都不干执行完毕</li>\n</ul>\n<p>&emsp;&emsp;大家看到， <strong>当<code>effect</code>收集函数内先依赖<code>computed</code>，并修改<code>computed</code>依赖的数据时，在<code>effect</code>外修改<code>computed</code>可能会导致<code>effect</code>无法正常响应。</strong> 这个不知道是bug还是处于什么考虑。</p>\n<h2 id=\"deferredcomputed\">deferredComputed</h2>\n<p>&emsp;&emsp;<code>deferredComputed</code>是在<code>effect</code>中使用时有异步的特性，当<code>effect</code>收集到<code>deferredComputed</code>依赖，<code>deferredComputed</code>的<code>value</code>发生变化并不会马上触发<code>effect</code>收集函数，而是等到下一次微任务执行。当直接获取<code>deferredComputed.value</code>时是同步执行的，会马上获取到最新值。</p>\n<p>&emsp;&emsp;<code>deferredComputed</code>也有懒加载的特性，也就是说也是根据自定义<code>effect</code>调度器实现的。当数据改变执行<code>triggerRefValue</code>来触发其他依赖了自身的<code>effect</code>收集函数的重新执行。也就是说当<code>deferredComputed</code>数据发生改变在下一次微任务执行<code>triggerRefValue</code>即可实现在<code>effect</code>中异步的特性。</p>\n<p>&emsp;&emsp;由于<code>deferredComputed</code>的调度器逻辑相对比较复杂，我们从拆开讲解，下面我们看看删减源码：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 异步computed类</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">DeferredComputedRefImpl<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> dep<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Dep <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span>\n\n  <span class=\"token keyword\">private</span> _value<span class=\"token operator\">!</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n  <span class=\"token keyword\">private</span> _dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> effect<span class=\"token operator\">:</span> ReactiveEffect<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> __v_isRef <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">readonly</span> <span class=\"token punctuation\">[</span>ReactiveFlags<span class=\"token punctuation\">.</span><span class=\"token constant\">IS_READONLY</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>getter<span class=\"token operator\">:</span> ComputedGetter<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> scheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effect <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReactiveEffect</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 被effect 引用有dep才需要延迟</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>scheduled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 获取比对值，决定是否执行 triggerRefValue</span>\n          <span class=\"token keyword\">const</span> valueToCompare <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value\n          <span class=\"token comment\">// 标识正在等待</span>\n          scheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n\n          <span class=\"token comment\">// 下一次微任务执行</span>\n          <span class=\"token function\">scheduler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 如果当前computed没有停用</span>\n            <span class=\"token comment\">// 并且主动获取值，查看比对值是否一直</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span>active <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> valueToCompare<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">triggerRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\">// 没有再等待冲刷</span>\n            scheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function\">_get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_dirty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      <span class=\"token comment\">// 执行effect获取返回值</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 获取值，主动获取一定能刷新值</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">trackRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">toRaw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">_get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">deferredComputed</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">getter</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ComputedRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DeferredComputedRefImpl</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>deferredComputed</code>大部分属性都跟<code>computed</code>差不多，不同的是调度器的定义，在获取<code>value</code>时将<code>trackRefValue</code>与值处理分离开来。</p>\n<p>&emsp;&emsp;首先我们看到调度器的处理，如果当前<code>deferredComputed</code>没有收集到依赖，也就是没有在<code>effect</code>中使用，那么就直接修改为脏数据即可，因为异步特性是针对<code>effect</code>的监听函数的。除此之外<code>deferredComputed</code>还会防抖，一次微任务中多次调度只会执行一次，使用<code>scheduled</code>变量来完成这一特性，在进入前记录当前<code>deferredComputed</code>正在执行任务，执行完毕后会恢复状态，当多次进入时会判断如果正在执行任务则直接忽略。最后在下一次微任务后如果值被修改则<code>triggerRefValue</code>，触发当前<code>deferredComputed</code>值被修改使得被引用的<code>effect</code>被重新执行。</p>\n<p>&emsp;&emsp;接下来我们看看<code>scheduler</code>函数中的具体实现细节：</p>\n<pre><code class=\"language-ts\"><span class=\"token comment\">// 微任务</span>\n<span class=\"token keyword\">const</span> tick <span class=\"token operator\">=</span> <span class=\"token builtin\">Promise</span><span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 任务队列</span>\n<span class=\"token keyword\">const</span> queue<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// 正在执行任务</span>\n<span class=\"token keyword\">let</span> queued <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n<span class=\"token comment\">// 任务调度器</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">scheduler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fn<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 如果正在执行任务仅添加到任务中即可</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>queued<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果没有执行任务标识正在执行，然后再下一次微任务中执行</span>\n    queued <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    tick<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>flush<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 冲刷，执行任务</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">flush</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取所有任务，然后执行</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 清空</span>\n  queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  queued <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>scheduler</code>中是使用<code>promise.then</code>来实现异步的，当任务进入时会存入到队列中。如果当前是队列首次执行，则在下一次微任务调用<code>flush</code>方法。<code>flush</code>中按顺序执行任务队列的所有方法，然后恢复状态。</p>\n<p>&emsp;&emsp;在任务执行期间，加入的任务始终会在下一次微任务一起执行，即使实在任务中加入任务，比如下方这段代码</p>\n<pre><code class=\"language-ts\"><span class=\"token function\">scheduler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">scheduler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>&emsp;&emsp;让我们回到<code>deferredComputed</code>，综合<code>scheduler</code>，也就是说，所有的更改会在一次微任务中按顺序执行。</p>\n<p>&emsp;&emsp;现在<code>deferredComputed</code>主要代码我们已经看完了，但是还有一些情况需要处理。我们看到上面<code>DeferredComputedRefImpl</code>源码实现中，只有当<code>valueToCompare</code>发生变化时才会调用<code>triggerRefValue</code>，通知依赖了当前<code>computed</code>的<code>effect</code>重新执行。</p>\n<p>&emsp;&emsp;<code>valueToCompare</code>是在执行微任务前缓存下来的，当不存在<code>dcEffect</code>依赖<code>deferredComputed</code>时是没问题的，因为会缓存<code>_value</code>，即使用户主动获取了<code>computed.value</code>改变了<code>this._value</code>，在下一次微任务比对的也是缓存的<code>_value</code>。</p>\n<p>&emsp;&emsp;当存在<code>dcEffect</code>依赖<code>deferredComputed</code>时就会出问题，比如存在<code>dc1</code>和<code>dc2</code>，<code>dc2</code>的值依赖<code>dc1</code>，而<code>dc1</code>只有一下次微任务才会执行<code>triggerRefValue</code>通知<code>dc2</code>调度器。所以<code>dc2</code>在下一次微任务时才会获取<code>valueToCompare</code>来比对决定是否执行<code>triggerRefValue</code>。假如用户通过<code>dc2.value</code>来强行刷新值的话，<code>_value</code>就会存储最新的值，在下一次微任务时拿到的<code>valueToCompare</code>会与<code>dc2.value</code>一样，就会导致<code>dc2</code>无法执行<code>triggerRefValue</code>，依赖了<code>dc2</code>的<code>effect</code>无法正常执行，比如下方代码：</p>\n<pre><code class=\"language-ts\"><span class=\"token keyword\">const</span> src <span class=\"token operator\">=</span> <span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> c1 <span class=\"token operator\">=</span> <span class=\"token function\">deferredComputed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> src<span class=\"token punctuation\">.</span>value <span class=\"token operator\">%</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> c2 <span class=\"token operator\">=</span> <span class=\"token function\">deferredComputed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> c1<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  count<span class=\"token operator\">++</span>\n  <span class=\"token keyword\">return</span> c2<span class=\"token punctuation\">.</span>value\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 1</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span>\n\nsrc<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token comment\">// 刷新c2，c2的_value是最新值</span>\nc2<span class=\"token punctuation\">.</span>value\n\n<span class=\"token builtin\">Promise</span><span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// c2 拿到的valueToCompare与this._get()值一致，无法发送triggerRefValue</span>\n  <span class=\"token comment\">// 1 </span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>&emsp;&emsp;其实解决方案也很简单，只需要在<code>deferredComputed</code>发生更改时，获取所有关联的<code>dceffect</code>，并让他们缓存当前<code>_value</code>*(<code>valueToCompare</code>)*，确保能正确的比对，我们看看<code>vue</code>是如何处理的：</p>\n<pre><code class=\"language-diff-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DeferredComputedRefImpl<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>getter<span class=\"token operator\">:</span> ComputedGetter<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 比较目标</span>\n<span class=\"inserted\">   <span class=\"content\"><span class=\"token keyword\">let</span> compareTarget<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span></span></span>\n    <span class=\"token comment\">// 是否需要比较目标比较</span>\n<span class=\"inserted\">   <span class=\"content\"><span class=\"token keyword\">let</span> hasCompareTarget <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span></span></span>\n    <span class=\"token keyword\">let</span> scheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effect <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReactiveEffect</span><span class=\"token punctuation\">(</span>getter<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>computedTrigger<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 如果是deferredComputed引起的调度</span>\n<span class=\"inserted\">       <span class=\"content\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>computedTrigger<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span></span>\n<span class=\"inserted\">         <span class=\"content\"><span class=\"token comment\">// 获取当前比对值，防止出现拿最新的不触发trigger的情感</span></span></span>\n<span class=\"inserted\">         <span class=\"content\"><span class=\"token comment\">// 如果不缓存值，当上一个缓冲区刷新之后，获取当前的都是最新值，则不会触发trigger</span></span></span>\n<span class=\"inserted\">         <span class=\"content\">compareTarget <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value</span></span>\n<span class=\"inserted\">         <span class=\"content\">hasCompareTarget <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span></span></span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>scheduled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 获取比对之</span>\n<span class=\"inserted\">         <span class=\"content\"><span class=\"token keyword\">const</span> valueToCompare <span class=\"token operator\">=</span> hasCompareTarget <span class=\"token operator\">?</span> compareTarget <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_value</span></span>\n          <span class=\"token comment\">// 标识正在等待</span>\n          scheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n          <span class=\"token comment\">// 恢复hasCompareTarget</span>\n<span class=\"inserted\">         <span class=\"content\">hasCompareTarget <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span></span></span>\n\n          <span class=\"token function\">scheduler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span>active <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> valueToCompare<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token function\">triggerRefValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            scheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 获取当前关联的deferredComputed依次触发调度器，并传入是computed触发标识</span>\n<span class=\"inserted\">       <span class=\"content\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> e <span class=\"token keyword\">of</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span></span>\n<span class=\"inserted\">         <span class=\"content\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>computed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span></span>\n<span class=\"inserted\">           <span class=\"content\">e<span class=\"token punctuation\">.</span>scheduler<span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span> <span class=\"token comment\">/* computedTrigger */</span><span class=\"token punctuation\">)</span></span></span>\n<span class=\"inserted\">         <span class=\"content\"><span class=\"token punctuation\">}</span></span></span>\n<span class=\"inserted\">       <span class=\"content\"><span class=\"token punctuation\">}</span></span></span>\n<span class=\"inserted\">     <span class=\"content\"><span class=\"token punctuation\">}</span></span></span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// 标识当前effect是deferredComputed</span>\n<span class=\"inserted\">   <span class=\"content\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span>computed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span></span></span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>dcEffect</code>会在附加<code>computed</code>属性设置为<code>true</code>，来标识当前<code>effect</code>属于<code>deferredComputed</code>。当<code>deferredComputed</code>值被修改引起调度器重新执行时，会获取所有关联的<code>dcEffect</code>，然后逐一执行他们的调度器，并注明执行是来源于<code>deferredComputed</code>。</p>\n<p>&emsp;&emsp;如果调度器是<code>deferredComputed</code>执行的，那么就需要缓存当前<code>_value</code>，确保能正确对比。<code>vue</code>中使用<code>hasCompareTarget</code>变量来标识是需要使用缓存值来比对还是直接使用<code>_value</code>来比对。当前<code>deferredComputed</code>又可能被其他<code>deferredComputed</code>依赖，也需要对被关联<code>deferredComputed</code>通知缓存<code>value</code>。这样就能处理这种情况了。</p>\n<p>&emsp;&emsp;到这里<code>computed</code>的具体实现了就已经看完了，完结撒花。</p>\n<p>上一章：<a href=\"https://bill-lai.github.io/article/4838fc56a04f95936f16\">vue3-ref源码解析</a></p>\n","desc":"阅读准备\n\n本文使用的vue版本为3.2.26。在阅读 computed 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 API了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。\n\n  在vue3中可以使用用户自定义的getter方法创建一个计算对象，计算对象通过."}}</script><script>!function(e){function t(t){for(var n,o,i=t[0],c=t[1],l=t[2],s=0,p=[];s<i.length;s++)o=i[s],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&p.push(a[o][0]),a[o]=0;for(n in c)Object.prototype.hasOwnProperty.call(c,n)&&(e[n]=c[n]);for(f&&f(t);p.length;)p.shift()();return u.push.apply(u,l||[]),r()}function r(){for(var e,t=0;t<u.length;t++){for(var r=u[t],n=!0,o=1;o<r.length;o++){var c=r[o];0!==a[c]&&(n=!1)}n&&(u.splice(t--,1),e=i(i.s=r[0]))}return e}var n={},o={1:0},a={1:0},u=[];function i(t){if(n[t])return n[t].exports;var r=n[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.e=function(e){var t=[];o[e]?t.push(o[e]):0!==o[e]&&{4:1}[e]&&t.push(o[e]=new Promise((function(t,r){for(var n="static/css/"+({}[e]||e)+"."+{3:"31d6cfe0",4:"4422e775"}[e]+".chunk.css",a=i.p+n,u=document.getElementsByTagName("link"),c=0;c<u.length;c++){var l=(f=u[c]).getAttribute("data-href")||f.getAttribute("href");if("stylesheet"===f.rel&&(l===n||l===a))return t()}var s=document.getElementsByTagName("style");for(c=0;c<s.length;c++){var f;if((l=(f=s[c]).getAttribute("data-href"))===n||l===a)return t()}var p=document.createElement("link");p.rel="stylesheet",p.type="text/css",p.onload=t,p.onerror=function(t){var n=t&&t.target&&t.target.src||a,u=new Error("Loading CSS chunk "+e+" failed.\n("+n+")");u.code="CSS_CHUNK_LOAD_FAILED",u.request=n,delete o[e],p.parentNode.removeChild(p),r(u)},p.href=a,document.getElementsByTagName("head")[0].appendChild(p)})).then((function(){o[e]=0})));var r=a[e];if(0!==r)if(r)t.push(r[2]);else{var n=new Promise((function(t,n){r=a[e]=[t,n]}));t.push(r[2]=n);var u,c=document.createElement("script");c.charset="utf-8",c.timeout=120,i.nc&&c.setAttribute("nonce",i.nc),c.src=function(e){return i.p+"static/js/"+({}[e]||e)+"."+{3:"c6f781a0",4:"23b5959c"}[e]+".chunk.js"}(e);var l=new Error;u=function(t){c.onerror=c.onload=null,clearTimeout(s);var r=a[e];if(0!==r){if(r){var n=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;l.message="Loading chunk "+e+" failed.\n("+n+": "+o+")",l.name="ChunkLoadError",l.type=n,l.request=o,r[1](l)}a[e]=void 0}};var s=setTimeout((function(){u({type:"timeout",target:c})}),12e4);c.onerror=c.onload=u,document.head.appendChild(c)}return Promise.all(t)},i.m=e,i.c=n,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/",i.oe=function(e){throw console.error(e),e};var c=this.webpackJsonpsource=this.webpackJsonpsource||[],l=c.push.bind(c);c.push=t,c=c.slice();for(var s=0;s<c.length;s++)t(c[s]);var f=l;r()}([])</script><script src="/static/js/2.b25e0f2c.chunk.js"></script><script src="/static/js/main.61927ba5.chunk.js"></script></body></html>