<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="theme-color" content="#000000"/><link rel="icon" href="/static/images/favicon.ico"/><link rel="apple-touch-icon" href="/static/images/logo192.png"/><link rel="stylesheet" href="/static/lib/simplemde.min.css"><title>vue3-effect源码解析 | bill-lai 的博客</title><link href="/static/css/main.e3177452.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="style_app__1yczT"><header class="style_slide__z5PNT style_slide__3Yi3e"><a href="/"><img src="/static/media/portrait.df7a5375.jpg" class="style_portrait__2GrBh" alt="portrait"/></a><div class="style_content__3GlZB"><div class="style_introduce__2UxnL"><h1><a href="/">bill-lai</a></h1><p>专注 WEB 端开发</p></div><ul class="style_navs__2yN9I"><li><a href="/">首页</a></li><li><a href="/archive">专题</a></li><li><a href="/special">归档</a></li></ul></div></header><div class="style_body__3Yz5T"><div class="style_layer__1ZQZt"><div class="style_main__XnHDF"><div> <h1 class="main-title">vue3-effect源码解析<span class="marker">2022-02-15 12:30</span></h1><div class="marked-body"><h2 id="阅读准备">阅读准备</h2>
<blockquote>
<p>本文使用的<code>vue</code>版本为<code>3.2.26</code>。在阅读 <code>effect</code> 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 <code>API</code>了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。</p>
</blockquote>
<p>&emsp;&emsp;通过上一章<a href="https://bill-lai.github.io/article/6452d43210bfdd32fd3c">vue3-reactive源码解析</a>，可以猜想到，<code>effect</code>主要职责是存储<code>Proxy</code> <code>track</code> <em>（收集）</em>的依赖，当<code>Proxy</code> <code>triggle</code> <em>（触发）</em>后查看<code>trigger</code>是否是<code>track</code>存储的依赖，如果是的话则执行监听函数。关于<code>Proxy</code>是如何<code>track</code>和<code>triggle</code>的可以看上一章<a href="https://bill-lai.github.io/article/6452d43210bfdd32fd3c">vue3-reactive源码解析</a>。</p>
<p>&emsp;&emsp;为了方便表达，我将用户传入<code>effect</code>的回调函数统称为监听函数，由<code>effect</code>包裹后的统称为收集函数。</p>
<p>通过文档和单例可以知道<code>effect</code>有以下特性</p>
<ul>
<li>传入的收集函数不会递归执行，就算当前<code>effect</code>内触发了已经收集的依赖。比如<code>effect(() =&gt; {rea.a; rea.a = 2})</code></li>
<li><code>effect</code>函数返回的也是函数，可以直接通过返回的函数执行监听函数。</li>
<li><code>effect</code>可以包裹<code>effect</code>返回的方法，会重新包装，当触发时会执行两次。</li>
<li><code>effect</code>可以在监听函数中再次调用<code>effect</code>，但是里层不会收集外层监听函数的依赖，外层也不会收集到里层的依赖，比如：</li>
</ul>
<pre><code class="language-js">  <span class="token keyword">const</span> rea <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 1, 2</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rea<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
    <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rea<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 2, 2</span>
  rea<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token comment">// 3</span>
  rea<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3</span>
</code></pre>
<ul>
<li><code>effect</code>第二个可选<code>json</code>参数，这个参数包含<code>lazy</code>, <code>scheduler</code>, <code>allowRecurse</code>, <code>onStop</code>, <code>onTrack</code>, <code>onTragger</code>属性<ul>
<li><code>lazy</code>：<code>boolean</code>，是否懒加载，如果是<code>true</code>调用<code>effect</code>不会立即执行监听函数，由用户手动触发。</li>
<li><code>scheduler</code>: <code>function</code>，被触发引起<code>effect</code>要重新收集依赖时的调度器，当传入时<code>effect</code>收到触发时不会重新执行监听函数而是执行这个<code>function</code>，由用户自己调度。</li>
<li><code>allowRecurse</code>：是否允许递归，这个参数需要和<code>scheduler</code>配套使用，是否允许递归<code>scheduler</code>，<strong>对监听函数无效</strong>。</li>
<li><code>onStop</code>：当<code>effect</code>被<code>stop</code> <em>（停止监听）</em>时的钩子。</li>
<li><code>onTrack</code>：当<code>effect</code>被<code>track</code>时的钩子。</li>
<li><code>onTrigger</code>：当<code>effect</code>被<code>trigger</code>时的钩子。</li>
</ul>
</li>
</ul>
<h2 id="思考实现">思考实现</h2>
<p>如果是我们自己编写<code>effect</code>会怎么实现呢？<a href="https://bill-lai.github.io/article/6452d43210bfdd32fd3c">上一章</a>知道了<code>Proxy</code>会通过<code>track</code>函数告知我们收集到了哪个对象的哪个<code>key</code>，会通过<code>triggle</code>函数因为哪个对象的哪个<code>key</code>引起了触发。加上上面的阅读准备我们知道了<code>effect</code>大概需求</p>
<ul>
<li><code>track</code>只收集<code>effect</code>内的依赖，<code>trigger</code>是触发<code>effect</code>的收集函数或调度器。</li>
<li>当<code>effect</code>收集函数被重新执行时需要清空之前收集的依赖并重新收集，因为收集的可能存在分支比如<code>if</code>，收集也是动态的。到这里是不是有大概的思路了，</li>
</ul>
<p>&emsp;&emsp;根据需我们可以简单的实现大概逻辑：</p>
<p><img src="/article/37495e00ab36e870f8dd/./image/effect.drawio.svg" alt="effect.svg"></p>
<p>&emsp;&emsp;在<code>vue</code>中<code>effect</code>实现的原理流程其实跟上图是差不多的，接下来我们就一份一份拆解出来看看它各个部分是怎么实现的，我们先看看<code>target</code>，<code>key</code>，<code>effect</code>的关系在里面是怎么实现的。</p>
<h2 id="dep">Dep</h2>
<p>&emsp;&emsp;<code>vue</code>中是如何存储<code>target</code>，<code>key</code>，<code>effect</code>的关系的，在<code>effect</code>源码中我们可以看到顶部有一段代码</p>
<pre><code class="language-js"><span class="token comment">// Dep: Set对象，可以存储多个effect对象</span>
<span class="token keyword">export</span> type Dep <span class="token operator">=</span> Set<span class="token operator">&lt;</span>ReactiveEffect<span class="token operator">></span> <span class="token operator">&amp;</span> TrackedMarkers

<span class="token comment">// Dep附加对象，用来标识effect的状态</span>
type TrackedMarkers <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * wasTracked
   */</span>
  <span class="token comment">// 之前被收集</span>
  w<span class="token operator">:</span> number
  <span class="token comment">/**
   * newTracked
   */</span>
  <span class="token comment">// 当前被收集</span>
  n<span class="token operator">:</span> number
<span class="token punctuation">}</span>

<span class="token comment">// key关联Dep的Map 为了方便我们叫他kDepMap</span>
type KeyToDepMap <span class="token operator">=</span> Map<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> Dep<span class="token operator">></span>
<span class="token comment">// Target -> kDepMap</span>
<span class="token keyword">const</span> targetMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token operator">&lt;</span>any<span class="token punctuation">,</span> KeyToDepMap<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>&emsp;&emsp;在<code>effect</code>源码文件中声明了一个类型为<code>WeakMap</code>的<code>targetMap</code>变量，这个<code>targetMap</code>就是存储监听函数执行期间<code>Proxy</code>中<code>track</code>出来的依赖与<code>effect</code>。</p>
<p>&emsp;&emsp;<code>Proxy</code>调用<code>track</code>时抛出的参数中有代理的<code>Target（raw）</code>和引起<code>track</code>的<code>key</code>，而一个<code>Target</code>可以有多个<code>key</code>引起<code>track</code>，<code>key</code>也可能是对象，因为<code>Target</code>可能是<code>Map</code>或者<code>WeakMap</code>，除了存储<code>Target</code>和<code>key</code>外，也要存储这个<code>key</code>是在哪些<code>effect</code>的监听函数中使用的，所以<code>vue</code>采用双<code>Map</code>的存储方式。<code>kDepMap</code>存储每个<code>key</code>和<code>effect</code>的引用关系，然后<code>targetMap</code>存储<code>target</code>和<code>kDepMap</code>的引用关系。</p>
<p>&emsp;&emsp;上面还使用了<code>ts</code>为<code>Dep</code>的类型来标记<code>kDepMap</code>的<code>value</code>，<code>Dep</code>在<code>Set</code>的基础上附加值为<code>number</code>属性<code>w</code>、<code>h</code>。<code>Dep</code>中的<code>w</code>和<code>n</code>是干什么用的呢，我们看到源码中的注释<code>wasTracked</code>和<code>newTracked</code>从字面意思可以猜测出来，应该是记录之前是否被收集和现在是否被收集。我们之前讲过，数据收集是动态的，所以每次执行收集前需要清空之前的依赖，然后附加上现在的依赖，确保依赖正确，比如下方的代码：</p>
<pre><code class="language-js"><span class="token keyword">const</span> reuser <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> 
  name<span class="token operator">:</span> <span class="token string">'bill'</span><span class="token punctuation">,</span> 
  sex<span class="token operator">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span>
  setLog<span class="token operator">:</span> <span class="token string">'name'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 第一次执行收集到的key是setLog、name</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">[</span>reuser<span class="token punctuation">.</span>setLog<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 更改后收集到的key是setLog、sex</span>
reuser<span class="token punctuation">.</span>setLog <span class="token operator">=</span> <span class="token string">'sex'</span>
</code></pre>
<p>&emsp;&emsp;<code>vue</code>中将这两个属性直接关联到<code>Dep</code>中，也就是说<code>Target</code>的每个<code>key</code>都有当前之前是否被收集、现在是否被收集的标识状态。按照平常的做法来说这种状态应该是附加到<code>effect</code>实例，因为<code>Dep</code>是<code>Set</code>它里面存储的不止是一个<code>effect</code>，每个<code>effect</code>都应该有状态，但是现在附加到了<code>Dep</code>上，也就意味着必须要对<code>Dep</code>的<code>w</code>、<code>n</code>做一些特殊的处理：</p>
<ul>
<li><strong>当<code>effect</code>函数执行完毕之后必须要还原<code>Dep</code>的<code>w</code>和<code>h</code>的状态，否则<code>Set</code>中其他<code>effect</code>使用就不正确了</strong></li>
<li><strong>当<code>effect</code>函数执行前必须恢复<code>w</code>属性（之前是否被<code>trick</code>）</strong></li>
<li><strong>当<code>effect</code>函数递归调用时，<code>w</code>和<code>h</code>属性必须能够完整记录每一层的状态</strong>，比如下方这种方式调用</li>
</ul>
<pre><code class="language-js">  <span class="token keyword">const</span> rea <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rea<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    rea<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rea<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>&emsp;&emsp;因为这些都是与<code>effect</code>中实现直接挂钩的，等我们讲到<code>effect</code>具体实现时再看看他们是怎么具体实现的。现在我们可以先思考<code>w</code>、<code>h</code>怎么实现这三点的，前两点都还好，只是恢复和还原状态，但是第三点要记录多层状态。要记录多层状态，而<code>w</code>、<code>h</code>又是<code>number</code>，可以得出结论，这两个属性是要用位运算符做多层状态管理，关于位运算符是怎么做状态的，大家可以看看我之前写的<a href="https://bill-lai.github.io/article/9c6d734aa72e04e0f8dd/">这篇文章</a>。递归调用<code>effect</code>时每一层<code>effect</code>，<code>w</code>、<code>h</code>都用一个特定的位来标识这一次<code>effect</code>的状态，在二进制中的用<code>1</code>表示<code>true</code>，<code>0</code>表示<code>false</code>这是常规做法。在<code>vue</code>中使用的是从第二位开始标记当前状态，每多一层就将当前标识状态的往前推一位，例如：</p>
<pre><code class="language-js">  <span class="token keyword">const</span> rea <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token comment">//初次生成</span>
  <span class="token comment">// key: a</span>
  <span class="token comment">// Dep: { w: 0, n: 0 }</span>
  <span class="token comment">//   w.toString(2): 00000000000000000000000000000000</span>
  <span class="token comment">//   n.toString(2): 00000000000000000000000000000000</span>
  <span class="token comment">//</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">//第一次收集</span>
    <span class="token comment">//  key: a</span>
    <span class="token comment">//  Dep: { w: 0, n: 2 }</span>
    <span class="token comment">//    w.toString(2): 00000000000000000000000000000000</span>
    <span class="token comment">//    n.toString(2): 00000000000000000000000000000010</span>
    <span class="token comment">//第二次收集，恢复已经被收集状态</span>
    <span class="token comment">//  key: a</span>
    <span class="token comment">//  Dep: { w: 2, n: 2 }</span>
    <span class="token comment">//    w.toString(2): 00000000000000000000000000000010</span>
    <span class="token comment">//    n.toString(2): 00000000000000000000000000000010</span>
    <span class="token comment">//</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rea<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token comment">// 进入内层</span>
      <span class="token comment">// 第一次收集</span>
      <span class="token comment">//   key: a</span>
      <span class="token comment">//   Dep: { w: 0, n: 6 }</span>
      <span class="token comment">//     w.toString(2): 00000000000000000000000000000000</span>
      <span class="token comment">//     n.toString(2): 00000000000000000000000000000110</span>
      <span class="token comment">// 第二次收集，恢复已经被收集状态</span>
      <span class="token comment">//   key: a</span>
      <span class="token comment">//   Dep: { w: 6, n: 6 }</span>
      <span class="token comment">//     w.toString(2): 00000000000000000000000000000110</span>
      <span class="token comment">//     n.toString(2): 00000000000000000000000000000110</span>
      <span class="token comment">//</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rea<span class="token punctuation">.</span>a<span class="token punctuation">)</span>

     <span class="token comment">//离开外层清空恢复进入状态</span>
     <span class="token comment">//第一次收集离开</span>
     <span class="token comment">// key: a</span>
     <span class="token comment">// Dep: { w: 0, n: 2 }</span>
     <span class="token comment">//   w.toString(2): 00000000000000000000000000000000</span>
     <span class="token comment">//   n.toString(2): 00000000000000000000000000000010</span>
     <span class="token comment">//第二次收集离开</span>
     <span class="token comment">// key: a</span>
     <span class="token comment">// Dep: { w: 2, n: 2 }</span>
     <span class="token comment">//   w.toString(2): 00000000000000000000000000000010</span>
     <span class="token comment">//   n.toString(2): 00000000000000000000000000000010</span>
     <span class="token comment">//</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">//离开外层清空恢复进入状态</span>
    <span class="token comment">//  key: a</span>
    <span class="token comment">//  Dep: { w: 0, n: 0 }</span>
    <span class="token comment">//    w.toString(2): 00000000000000000000000000000000</span>
    <span class="token comment">//    n.toString(2): 00000000000000000000000000000000</span>
    <span class="token comment">//</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  rea<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
</code></pre>
<p>&emsp;&emsp;要标识当前递归调用了多少次，还需要用一个变量来记录，在<code>effect</code>中使用<code>effectTrackDepth</code>变量来记录，现在来看看<code>Dep</code>的具体管理方法：</p>
<pre><code class="language-js"><span class="token comment">// -----effect文件中------</span>
<span class="token comment">// 当前effect层叠数</span>
<span class="token keyword">let</span> effectTrackDepth <span class="token operator">=</span> <span class="token number">0</span>
<span class="token comment">// 当前trick需要操作的bit</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> trackOpBit <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment">// 在使用时 trackOpBit = 1 &lt;&lt; ++effectTrackDepth</span>
<span class="token comment">// 也就是effect递归多少次就往前推多少位</span>
<span class="token comment">// effectTrackDepth = 0    trackOpBit = 00000000000000000000000000000010</span>
<span class="token comment">// effectTrackDepth = 1    trackOpBit = 00000000000000000000000000000100</span>
<span class="token comment">// effectTrackDepth = 2    trackOpBit = 00000000000000000000000000001000</span>
<span class="token comment">// effectTrackDepth = 3    trackOpBit = 00000000000000000000000000010000</span>
<span class="token comment">// ----------------------</span>

<span class="token comment">// 创建dep</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> createDep <span class="token operator">=</span> <span class="token punctuation">(</span>effects<span class="token operator">?</span><span class="token operator">:</span> ReactiveEffect<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter">Dep</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>ReactiveEffect<span class="token operator">></span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span> <span class="token keyword">as</span> Dep
  <span class="token comment">// 初始化</span>
  dep<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token number">0</span>
  dep<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">return</span> dep
<span class="token punctuation">}</span>

<span class="token comment">// 传入的Dep 查看当关联key在effect中之前是否被track</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> wasTracked <span class="token operator">=</span> <span class="token punctuation">(</span>dep<span class="token operator">:</span> Dep<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter">boolean</span> <span class="token operator">=></span> <span class="token punctuation">(</span>dep<span class="token punctuation">.</span>w <span class="token operator">&amp;</span> trackOpBit<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span>

<span class="token comment">// 传入的Dep 查看当关联key在effect中现在是否被track</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> newTracked <span class="token operator">=</span> <span class="token punctuation">(</span>dep<span class="token operator">:</span> Dep<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter">boolean</span> <span class="token operator">=></span> <span class="token punctuation">(</span>dep<span class="token punctuation">.</span>n <span class="token operator">&amp;</span> trackOpBit<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span>
</code></pre>
<p>&emsp;&emsp;为了方便操作<code>vue</code>会创建一个<code>trackOpBit</code>变量，这个变量根据当前<code>effect</code>的递归往前推进，保证<code>trackOpBit</code>的二进制位数中为<code>1</code>的位置和<code>w</code>、<code>h</code>二进制数标识当前<code>effect</code>状态的位置是保持一致的。当需要判断<code>key</code>在当前<code>effect</code>之前和现在是否被收集时只需要<code>dep.w &amp; trackOpBit</code>和<code>dep.n &amp; trackOpBit</code>是否大于<code>0</code>就行了，如果对于 <code>&amp;</code>运算符不了解可以看看我之前写的<a href="https://bill-lai.github.io/article/9c6d734aa72e04e0f8dd/">这篇文章</a>。</p>
<p>&emsp;&emsp;通过<code>Dep</code>记录的这某个<code>key</code>上一次是否被收集和现在是否被收集，我们可以猜测到<code>vue</code>是怎么管理<code>targetMap</code>的了，<code>vue</code>中重新收集时 <em>（即调用<code>effect</code>监听函数）</em>可能不是简单粗暴的直接剔除<code>KeyToDepMap</code>中<code>Set</code>所有当前的<code>effect</code>，然后再收集，而是：</p>
<ul>
<li><strong>之前<code>key</code>被收集，但是当前没有收集，则在<code>key</code>关联的<code>Dep</code>中剔除当前<code>effect</code></strong></li>
<li><strong>之前<code>key</code>没有被收集，当时当前被收集<code>，则在</code>key<code>关联的</code>Dep<code>中添加当前</code>effect`</strong></li>
<li><strong>之前<code>key</code>被收集，当前也被收集，则保持不变</strong></li>
</ul>
<h2 id="effect">effect</h2>
<p>&emsp;&emsp;接下来我们看看<code>effect</code>函数的具体代码</p>
<pre><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">const</span> extend <span class="token operator">=</span> Object<span class="token punctuation">.</span>assign
<span class="token comment">// 创建effect函数</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> effect<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> any<span class="token operator">></span><span class="token punctuation">(</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token punctuation">,</span>
  options<span class="token operator">?</span><span class="token operator">:</span> ReactiveEffectOptions
<span class="token punctuation">)</span><span class="token operator">:</span> ReactiveEffectRunner <span class="token punctuation">{</span>
  <span class="token comment">// 如果当前fn已经是收集函数包装后的函数，则获取监听函数当做入参</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token keyword">as</span> ReactiveEffectRunner<span class="token punctuation">)</span><span class="token punctuation">.</span>effect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fn <span class="token operator">=</span> <span class="token punctuation">(</span>fn <span class="token keyword">as</span> ReactiveEffectRunner<span class="token punctuation">)</span><span class="token punctuation">.</span>effect<span class="token punctuation">.</span>fn
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建effect对象</span>
  <span class="token keyword">const</span> _effect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveEffect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  <span class="token comment">// 将用户传入的参数附加到effect对象上</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">extend</span><span class="token punctuation">(</span>_effect<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    <span class="token comment">// 如果有定义域作用于则记录，这个我们后面章节再讲，这里不影响主流程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>scope<span class="token punctuation">)</span> <span class="token function">recordEffectScope</span><span class="token punctuation">(</span>_effect<span class="token punctuation">,</span> options<span class="token punctuation">.</span>scope<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果不是懒加载则立即执行包装后的监听函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options <span class="token operator">||</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 绑定收集函数的this对象，和effect对象</span>
  <span class="token keyword">const</span> runner <span class="token operator">=</span> _effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>_effect<span class="token punctuation">)</span> <span class="token keyword">as</span> ReactiveEffectRunner
  runner<span class="token punctuation">.</span>effect <span class="token operator">=</span> _effect
  <span class="token keyword">return</span> runner
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>effect</code>函数主要是创建<code>ReactiveEffect</code>对象，将用户传入的参数附加到对象上，履行<code>lazy</code>参数的职责。</p>
<p>&emsp;&emsp;<code>effect</code>返回的是<code>effect.run</code>函数，这个函数的<code>effect</code>属性会指向<code>effect</code>对象，<code>this</code>也会设置为<code>effect</code>对象。所以当懒加载时，或者用户主动执行<code>effect</code>包装后的监听函数，也能够正确的<code>track</code>。</p>
<!-- &emsp;&emsp;`effect.run()`函数主要是设置`currentEffect`让`track`可以被正常设置，并清空之前存储的映射关系。 -->

<p>&emsp;&emsp;我们看到入参时会查看监听函数是否是<code>effect</code>包装后的函数，如果是会拿到未包装前的监听函数 <em>（存储再<code>effect</code>对象的<code>fn</code>属性上）</em>再创建<code>effect</code>，所以**<code>effect</code>可以包裹<code>effect</code>返回的方法，会重新包装，当触发时会执行两次。**</p>
<p>&emsp;&emsp;这里<code>ReactiveEffect</code>采用了<code>class</code>写法，每个<code>effect</code>函数都会创建一个实例，接下来我们看看这个<code>class</code>的具体代码</p>
<pre><code class="language-js"><span class="token comment">// 最多30个互相引用，如果超出则清理</span>
<span class="token keyword">const</span> maxMarkerBits <span class="token operator">=</span> <span class="token number">30</span>
<span class="token comment">// 正在执行的effect栈</span>
<span class="token keyword">const</span> effectStack<span class="token operator">:</span> ReactiveEffect<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// 当前正在执行的effect</span>
<span class="token keyword">let</span> activeEffect<span class="token operator">:</span> ReactiveEffect <span class="token operator">|</span> <span class="token keyword">undefined</span>

<span class="token keyword">let</span> effectTrackDepth <span class="token operator">=</span> <span class="token number">0</span>

<span class="token comment">// effect对象</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ReactiveEffect</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> any<span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment">// 当前对象是否是有效的，为false则是已加stop的了</span>
  active <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// 记录当前effect 收集到的所有key对应的Dep</span>
  deps<span class="token operator">:</span> Dep<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token comment">// 是否是computed 创建后可以附加</span>
  computed<span class="token operator">?</span><span class="token operator">:</span> boolean
  <span class="token comment">// 是否允许递归响应</span>
  allowRecurse<span class="token operator">?</span><span class="token operator">:</span> boolean
  <span class="token comment">// 停止监听钩子</span>
  onStop<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>
  <span class="token comment">// 被收集时钩子</span>
  onTrack<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>
  <span class="token comment">// 被触发时钩子</span>
  onTrigger<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>

  <span class="token comment">// 构造函数</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token comment">// 监听函数</span>
    <span class="token keyword">public</span> <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token punctuation">,</span>
    <span class="token comment">// 调度器</span>
    <span class="token keyword">public</span> scheduler<span class="token operator">:</span> EffectScheduler <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token comment">// 作用域</span>
    scope<span class="token operator">?</span><span class="token operator">:</span> EffectScope <span class="token operator">|</span> <span class="token keyword">null</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录当前对象的空间范围</span>
    <span class="token function">recordEffectScope</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> scope<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 收集函数</span>
  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果当前effect已经被stop</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 直接监听函数，不做收集逻辑</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 查看当前调度栈是否包含当前对象，如果包含说明是嵌套运行，不再执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>effectStack<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前effect入栈</span>
        effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>activeEffect <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 开启收集</span>
        <span class="token function">enableTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">// 根据层叠数更改trackOpBit</span>
        trackOpBit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>effectTrackDepth

        <span class="token comment">// 查看当前effect层叠数是否超过允许的最大记录数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTrackDepth <span class="token operator">&lt;=</span> maxMarkerBits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 记录恢复上一次dep状态 也就是更改w</span>
          <span class="token function">initDepMarkers</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 如果超过了最大bit记录数，则清除当前effect关联的所有Dep映射</span>
          <span class="token function">cleanupEffect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果当前effect轮询个数没超限制</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTrackDepth <span class="token operator">&lt;=</span> maxMarkerBits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 整理effect deps 删除失效无用的dep, 恢复 dep w n状态</span>
          <span class="token function">finalizeDepMarkers</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 恢复执行位数</span>
        trackOpBit <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">--</span>effectTrackDepth

        <span class="token comment">// 恢复收集状态</span>
        <span class="token function">resetTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 出栈</span>
        effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 将正在使用effect替换成栈顶</span>
        <span class="token keyword">const</span> n <span class="token operator">=</span> effectStack<span class="token punctuation">.</span>length
        activeEffect <span class="token operator">=</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> effectStack<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token keyword">undefined</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 停止监听</span>
  <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 清除当前effect关联的所有Dep映射</span>
      <span class="token function">cleanupEffect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onStop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>active <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;关于<code>computed</code>、<code>scope</code>和<code>recordEffectScope</code>我们后面的章节再讲，这里不会影响当前业务，先忽略它们。</p>
<p>&emsp;&emsp;<code>effect</code>函数传入的参数都会附加到<code>ReactiveEffect</code>对象上，其中<code>scheduler</code>可以通过构造函数传入。<code>effect</code>对象上还会附加<code>deps</code>属性，这个属性是记录<code>effect</code>关联的所有<code>key</code>的<code>Dep</code>对象。这里附加是因为响应式对象不止只有<code>reactive</code>, 还有其他响应式对象的依赖需要存储，其他响应式对象我们后面再讲。还有一方面是为了方便的管理，比如在执行前会还原当前<code>Dep</code>在之前是否被收集，执行完毕后需要对当前关联的所有<code>Dep</code>还原状态，停止监听时直接通过关联的<code>dep</code>删除<code>effect</code>。</p>
<p>&emsp;&emsp;在<code>effect</code>对象中使用<code>run</code>方法执行监听方法和附加状态。当<code>effect</code>对象被停用时调用<code>run</code>方法只是执行监听方法。</p>
<p>&emsp;&emsp;当进入收集函数时会进行检测当前对象是否已经在执行栈内，如果在栈内则中断执行，我们可以看到<code>allowRecurse</code>参数并没有在这里使用上，所以即使声明了<code>allowRecurse</code>参数对于收集函数的递归也是没什么效果。</p>
<p>&emsp;&emsp;正式进入会将正在执行的<code>effect</code>对象替换成当前<code>effect</code>对象，并且入栈。当在一个收集函数内调用另一个收集函数时时会叠加<code>effectTrackDepth</code>变量。还有我们之前说的<code>trackOpBit</code>变量，确保<code>trackOpBit</code>的中<code>1</code>的位数是跟<code>Dep</code>的<code>w</code>、<code>h</code>标识当前<code>effect</code>的位置是一致的，这样就能正确的使用<code>wasTracked</code>和<code>newTracked</code>方法。</p>
<p>&emsp;&emsp;收集函数还有个最大叠层数限制这个层叠数是30，在<code>maxMarkerBits</code>中声明。在<code>js</code>中<code>number</code>中使用32位的二进制数来表示数字的，第32位是符号位（0为正，1为负），那就是说最多能表示31个状态，而在<code>w</code>、<code>n</code>中最后一位没有使用，第一次进去是使用<code>1 &lt;&lt; 1</code>，直接从第二位开始的。所以最大的层数只能是<code>30</code>。</p>
<p>&emsp;&emsp;执行收集函数时是怎么恢复上次是否被收集的状态呢，因为每个<code>effect</code>对象都记录了<code>key</code>关联上的<code>dep</code>（ *<code>deps</code>*），当最新进入时，这些<code>Dep</code>就是上次的收集值，如果当前层叠数没超过30次，只需要在最新执行前将这些<code>dep</code>都打上之前被收集的标记就行了，在收集函数中使用<code>initDepMarkers</code>函数来实现的，下面我们看看源码</p>
<pre><code class="language-js"><span class="token comment">// 初始effect dep 的 记录</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">initDepMarkers</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> deps <span class="token punctuation">}</span><span class="token operator">:</span> ReactiveEffect</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">|=</span> trackOpBit <span class="token comment">// set was tracked</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;如果层叠数超过30次呢？这时候<code>w</code>，<code>h</code>无法正确的记录状态了，要怎么正确的收集和更新<code>dep</code>呢？因为无法记录状态，所以不知道之前是否收集过，那么就执行简单粗暴的方法，直接将之前<code>effect</code>对象收集的<code>Dep</code>删除掉，并删掉<code>Dep</code>中<code>effect</code>对象的引用，那新增加的就一定是正确的，这样就绕过需要状态的问题了。在<code>effect</code>是通过<code>cleanupEffect</code>方法清空当前<code>effect</code>对象与<code>Dep</code>的互相引用的，我们看看实现这个方法的实现</p>
<pre><code class="language-js"><span class="token comment">// 清空当前effect对象与Dep的互相引用的</span>
<span class="token keyword">function</span> <span class="token function">cleanupEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token operator">:</span> ReactiveEffect</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> deps <span class="token punctuation">}</span> <span class="token operator">=</span> effect
  <span class="token comment">// 清除Dep中effect的引用</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    deps<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;到这我们就看完了执行前的准备就已经完成，现在看看执行后effect的deps和Dep对象的处理是怎么处理的。</p>
<ul>
<li><p>如果已经超过最大层叠数，则<code>effect</code>的<code>deps</code>和<code>Dep</code>不需要做任何处理，因为之前收集的<code>Dep</code>已经被删除了，现在存下来的肯定是最新，而且也没用到<code>Dep</code>的<code>w</code>和<code>n</code>状态。</p>
</li>
<li><p>如果没超过最大层叠数，<code>Dep</code>的<code>w</code>和<code>n</code>因为是被多个<code>effect</code>对象引用，所以执行后要恢复到进入时的状态，确保其他<code>effect</code>对象使用时是正确的。为什么不能直接还原到最初的状态 *(<code>{w: 0, n: 0}</code>)*，因为收集函数可能互相引入，当前收集函数执行完，执行权还要交还给上一个收集函数，要确保上一个收集函数内的<code>w</code>、<code>h</code>状态正确。除了恢复状态我们还要更新<code>effect</code>对象的<code>deps</code>属性，在执行前都打上了被收集的标识，那么执行后只需要查看<code>key</code>关联的<code>Dep</code>现在是否被收集就能判断是需要删除或保留 <em>（添加是在<code>trick</code>方法进行的）</em>。在<code>vue</code>中是使用<code>finalizeDepMarkers</code>函数来管理这部分需求的，接下来我们看看实现：</p>
</li>
</ul>
<pre><code class="language-js"><span class="token comment">// 更新effect对象的deps属性</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">finalizeDepMarkers</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">effect<span class="token operator">:</span> ReactiveEffect</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取deps</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> deps <span class="token punctuation">}</span> <span class="token operator">=</span> effect
  <span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ptr <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> dep <span class="token operator">=</span> deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token comment">// 如果之前dep已经收集，但是当前没有被收集，直接删除</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wasTracked</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">newTracked</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新deps</span>
        deps<span class="token punctuation">[</span>ptr<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> dep
      <span class="token punctuation">}</span>
      <span class="token comment">// clear bits</span>
      <span class="token comment">// 清除dep在这次收集函数中的状态</span>
      dep<span class="token punctuation">.</span>w <span class="token operator">&amp;=</span> <span class="token operator">~</span>trackOpBit
      dep<span class="token punctuation">.</span>n <span class="token operator">&amp;=</span> <span class="token operator">~</span>trackOpBit
    <span class="token punctuation">}</span>
    <span class="token comment">// 更新deps</span>
    deps<span class="token punctuation">.</span>length <span class="token operator">=</span> ptr
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>  如果之前收集过但是现在没收集的则直接删除，否则就保留，并且每个<code>dep</code>中标识当前<code>effect</code>状态的位标识符都重置为进入时的状态。这个函数通过记录当前保留的总数，然后要删除的<code>dep</code>的位置替换成要保留的<code>dep</code>，最后更新<code>length</code>，写的也是相当精妙。</p>
<p>&emsp;&emsp;在恢复<code>dep</code>状态和更新<code>effect</code>对象的<code>deps</code>后，也会将当前<code>trackOpBit</code>、<code>activeEffect</code>、<code>effectStack</code>恢复到进入前状态。到这里收集方法就已经看完了，接下来我们看看实例上的另外一个方法<code>stop</code>，这个方法相对比较简单，只是清空<code>targetMap</code>中当前<code>effect</code>对象引用，调用停用钩子，并更改当前<code>effect</code>对象的状态 <em>（<code>active</code>）</em>为已经被停用。<code>effect</code>中还为这个方法对外提供了一个主动调起的辅助方法<code>stop</code>:</p>
<pre><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token parameter">runner<span class="token operator">:</span> ReactiveEffectRunner</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  runner<span class="token punctuation">.</span>effect<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;到这里<code>effect</code>对象里面具体的实现已经讲完了，那<code>track</code>又是怎么存储<code>effect</code>到<code>Dep</code>的，又是怎么将<code>effect</code>和<code>Dep</code>两者关联的呢，接下来让我们探索<code>track</code>里的具体实现。</p>
<h2 id="track函数">track函数</h2>
<p>&emsp;&emsp;让我们回顾一下之前内容，<code>track</code>函数是在<code>Proxy</code>的基础拦截器或者是集合修改器中获取数据时触发的，主要是关联<code>effect</code>跟收集到的依赖，接下来我们看看<code>track</code>函数的具体实现，先看看具体代码</p>
<pre><code class="language-js"><span class="token comment">// 当前是否正在收集，当前开启收集，并且有正在使用的effect对象</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> shouldTrack <span class="token operator">&amp;&amp;</span> activeEffect <span class="token operator">!==</span> <span class="token keyword">undefined</span>
<span class="token punctuation">}</span>

<span class="token comment">// 收集effect对象的依赖建立关系</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> object<span class="token punctuation">,</span> type<span class="token operator">:</span> TrackOpTypes<span class="token punctuation">,</span> key<span class="token operator">:</span> unknown</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果当前没有进行收集则直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取 KeyToDepMap（keys -> Dep）</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果不存在则初始化KeyToDepMap</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    targetMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取当前 key的Dep</span>
  <span class="token keyword">let</span> dep <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 如果不存在则创建Dep</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>dep <span class="token operator">=</span> <span class="token function">createDep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果是开发环境则记录具体信息</span>
  <span class="token keyword">const</span> eventInfo <span class="token operator">=</span> __DEV__
    <span class="token operator">?</span> <span class="token punctuation">{</span> effect<span class="token operator">:</span> activeEffect<span class="token punctuation">,</span> target<span class="token punctuation">,</span> type<span class="token punctuation">,</span> key <span class="token punctuation">}</span>
    <span class="token operator">:</span> <span class="token keyword">undefined</span>

  <span class="token function">trackEffects</span><span class="token punctuation">(</span>dep<span class="token punctuation">,</span> eventInfo<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>track</code>函数的逻辑并不复杂，首先检测当前是否正在收集，这个判断就是当前<code>trackStack</code>栈顶是开启了收集，并且当前正在执行收集函数，如果不是正在收集则直接退出，确保只有正在执行收集函数时才能进入。然后查看映射关系中是否存在当前<code>Target</code>的<code>KeyToDepMap（keys -&gt; Dep）</code>如果不存在则创建，在通过<code>key</code>查找是否有<code>Dep</code>没有则创建。如果是开发环境还会创建需要附加到钩子的具体收集信息，最后调用<code>trackEffects</code>方法，可以猜测得到<code>trackEffects</code>才是真正实现具体业务的方法。</p>
<p>&emsp;&emsp;下面我们看看<code>trackEffects</code>的具体实现代码：</p>
<pre><code class="language-js">
<span class="token comment">// track，更改Dep状态，更新effect对象的deps</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">trackEffects</span><span class="token punctuation">(</span>
  <span class="token parameter">dep<span class="token operator">:</span> Dep<span class="token punctuation">,</span>
  debuggerEventExtraInfo<span class="token operator">?</span><span class="token operator">:</span> DebuggerEventExtraInfo</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 是否是新增的依赖</span>
  <span class="token keyword">let</span> shouldTrack <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token comment">// 查看当前层叠数是否能超过了记录的最大限制</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTrackDepth <span class="token operator">&lt;=</span> maxMarkerBits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 查看是否记录过当前依赖</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">newTracked</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 记录是当前收集的依赖</span>
      dep<span class="token punctuation">.</span>n <span class="token operator">|=</span> trackOpBit <span class="token comment">// set newly tracked</span>
      <span class="token comment">// 如果effect之前已经收集过，则不是新增依赖</span>
      shouldTrack <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">wasTracked</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果层叠数超过了最大，则查看当前dep在effect中实收存储过</span>
    <span class="token comment">// 因为超过最大进入前会清空所有dep，</span>
    <span class="token comment">// 第一次进入一定会收集，当收集重复key时才会跳过</span>
    shouldTrack <span class="token operator">=</span> <span class="token operator">!</span>dep<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>activeEffect<span class="token operator">!</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果是新增的收集</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// dep添加当前正在使用的effect</span>
    dep<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token operator">!</span><span class="token punctuation">)</span>
    <span class="token comment">// effect的deps也记录当前dep 双向引用</span>
    activeEffect<span class="token operator">!</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
    <span class="token comment">// 如果当前是开发环境，还要执行onTrack钩子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">&amp;&amp;</span> activeEffect<span class="token operator">!</span><span class="token punctuation">.</span>onTrack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      activeEffect<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">onTrack</span><span class="token punctuation">(</span>
        Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>
          <span class="token punctuation">{</span>
            effect<span class="token operator">:</span> activeEffect<span class="token operator">!</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          debuggerEventExtraInfo
        <span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;没超过最大层叠数时，收集函数收集到的<code>Dep</code>需要打上当前被收集的状态，给<code>effect</code>对象执行完毕后更新<code>deps</code>属性使用性。如果当前收集到了<code>dep</code>，但是之前不存在，说明这个<code>dep</code>是新增的。当超过最大层叠数时执行前就清空之前的所有<code>Dep</code>中当前<code>effect</code>对象的引用，所以当进入收集函数时所有<code>dep</code>就都是新增的。新增的<code>dep</code>时需要将当前<code>effect</code>添加到这个<code>Dep</code>中，并且将这个<code>dep</code>添加到当前<code>effect</code>的deps中，然后触发收集钩子。</p>
<p>&emsp;&emsp;到这里<code>track</code>函数里面具体的实现已经讲完了，<code>effect</code>通过监听函数执行前设置当前<code>effect</code>，并使用<code>Dep</code>的<code>w</code>和<code>n</code>属性标记状态，然后在<code>track</code>中使用，通过这种方式确定当前是否在<code>effect</code>内收集到的依赖，确定状态，更新状态。</p>
<h2 id="triggle-函数">triggle 函数</h2>
<p>&emsp;&emsp;接下来我们看看<code>triggle</code>函数是如何通过<code>target</code>，<code>key</code>和<code>targetMap</code>存储库确定要执行的收集函数。</p>
<pre><code class="language-js"><span class="token comment">// trigger 值变化</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span>
  <span class="token parameter">target<span class="token operator">:</span> object<span class="token punctuation">,</span>
  type<span class="token operator">:</span> TriggerOpTypes<span class="token punctuation">,</span>
  key<span class="token operator">?</span><span class="token operator">:</span> unknown<span class="token punctuation">,</span>
  newValue<span class="token operator">?</span><span class="token operator">:</span> unknown<span class="token punctuation">,</span>
  oldValue<span class="token operator">?</span><span class="token operator">:</span> unknown<span class="token punctuation">,</span>
  oldTarget<span class="token operator">?</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>unknown<span class="token punctuation">,</span> unknown<span class="token operator">></span> <span class="token operator">|</span> Set<span class="token operator">&lt;</span>unknown<span class="token operator">></span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前target的KeyToDepMap</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// never been tracked</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 需要触发的deps</span>
  <span class="token keyword">let</span> deps<span class="token operator">:</span> <span class="token punctuation">(</span>Dep <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">CLEAR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果是清除当前数据（Set和Map中的操作），那所有dep都应该触发</span>
    deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>depsMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'length'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是修改数组长度，</span>
    <span class="token comment">// length和被删除的下标的key 关联的dep都应该被触发</span>
    depsMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">dep<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'length'</span> <span class="token operator">||</span> key <span class="token operator">>=</span> <span class="token punctuation">(</span>newValue <span class="token keyword">as</span> number<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先获取当前key关联的deps</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// also run for iteration key on ADD | DELETE | Map.SET</span>
    <span class="token comment">// 判别操作类型，</span>
    <span class="token comment">// 有些操作会关联到其他操作，需要分别判断</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果是增加操作</span>
      <span class="token keyword">case</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">ADD</span><span class="token operator">:</span>
        <span class="token comment">// 数组需要单独判断，之前我们说过数组的迭代收集到的key是length</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 因为是新增，获取迭代收集的dep</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isMap</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果是map还需要收集MAP_KEY_ITERATE_KEY</span>
            deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">MAP_KEY_ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isIntegerKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 如果是数组新增下标那么length一定会修改</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'length'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>

      <span class="token comment">// 如果是删除操作</span>
      <span class="token keyword">case</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">DELETE</span><span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 删除迭代都需要重新执行</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isMap</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">MAP_KEY_ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 因为删除操作一定会有length属性的变化，会引起length的triggle，这里就不需要重复收集</span>
        <span class="token keyword">break</span>
      <span class="token comment">// 如果是更改</span>
      <span class="token keyword">case</span> TriggerOpTypes<span class="token punctuation">.</span><span class="token constant">SET</span><span class="token operator">:</span>
        <span class="token comment">// 用户可能直接获取map.values或者 map.entries直接拿到value</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isMap</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ITERATE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 附加trigger调试信息给onTrigger钩子使用</span>
  <span class="token keyword">const</span> eventInfo <span class="token operator">=</span> __DEV__
    <span class="token operator">?</span> <span class="token punctuation">{</span> target<span class="token punctuation">,</span> type<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> oldTarget <span class="token punctuation">}</span>
    <span class="token operator">:</span> <span class="token keyword">undefined</span>

  <span class="token comment">// 假如只有一个Dep依赖则直接triggerEffects</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">triggerEffects</span><span class="token punctuation">(</span>deps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> eventInfo<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">triggerEffects</span><span class="token punctuation">(</span>deps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 假如有多个deps需要对内部的effect做一遍去重</span>
    <span class="token keyword">const</span> effects<span class="token operator">:</span> ReactiveEffect<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> dep <span class="token keyword">of</span> deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        effects<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>dep<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffects</span><span class="token punctuation">(</span><span class="token function">createDep</span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span><span class="token punctuation">,</span> eventInfo<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">triggerEffects</span><span class="token punctuation">(</span><span class="token function">createDep</span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>trigger</code>不仅只是获取<code>get</code>在<code>targetMap</code>指定<code>key</code>的<code>Dep</code>，因为数据操作中有很多关联性的东西，比如新增和删除都需要重新触发迭代操作，下面我们详细分析各个操作的关联性。</p>
<ul>
<li>当<code>Map</code>执行<code>clear</code>时，需要触发所有之前收集的effect</li>
<li>当<code>Array</code>更新<code>length</code>时，之前收集到<code>length</code>值大于当前<code>length</code>值，那么存储库中之前收集到的下标小于等于当前<code>length</code>的<code>key</code>关联的<code>Dep</code>需要重新触发，因为有可能之前有值，现在值被删除；为什么是有可能呢因为当收集到超出边界的下标时更改<code>length</code>也会重复触发，例如：</li>
</ul>
<pre><code class="language-js">  <span class="token keyword">const</span> rearr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">as</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rearr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rearr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  rearr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 1 undefined </span>
  <span class="token comment">// undefined undefined</span>
</code></pre>
<ul>
<li>当添加数据时，所有依赖函数收集到<code>key</code>为<code>ITERATE_KEY</code>、<code>Target</code>为<code>Map</code>中<code>Key</code>为<code>MAP_KEY_ITERATE_KEY</code>和<code>Target</code>为<code>Arrat</code>的<code>key</code>为<code>length</code>都应该触发，前两个很好理解，添加自然迭代就需要触发，但是第三个不是添加也会更改<code>length</code>吗，为什么也需要触发呢？这是因为当使用<code>api</code>时底层里面会先添加数据，这时数据内的<code>length</code>直接就被更改了，当拦截到<code>length</code>更改时已经获取不到旧值，前面我们看<code>Proxy</code>的<code>set</code>处理器触发前会做一条判断，那就是只有<code>key</code>的<code>value</code>更改了才会触发，这里<code>length</code>始终不会触发，因为始终是一致，所以当添加时就应该要触发。</li>
</ul>
<pre><code class="language-js">  <span class="token keyword">const</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token comment">// 4 4 undefined</span>
<span class="token comment">// length 5 5</span>
t<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token comment">// 5 4 undefined</span>
<span class="token comment">// 4 5 4</span>
<span class="token comment">// length 6 6</span>
</code></pre>
<ul>
<li>当删除数据时，所有依赖函数收集到<code>key</code>为<code>ITERATE_KEY</code>、<code>Target</code>为<code>Map</code>中<code>Key</code>为<code>MAP_KEY_ITERATE_KEY</code>都应该触发，为什么这里就不需要触发<code>Target</code>为<code>Array</code>key为<code>length</code>的<code>effect</code>，这是因为底层删除数组某项时都是通过更改<code>length</code>来实现，能够获取到旧值，当<code>length</code>新旧值发生更改时能够<code>trigger</code>所以就不需要重复收集了。</li>
</ul>
<pre><code class="language-js"><span class="token operator">...</span>
t<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token comment">// length 3 4</span>
<span class="token comment">// length 3 3</span>
</code></pre>
<ul>
<li>当更改数据时，所有依赖收集到<code>Map</code>中<code>key</code>为<code>ITERATE_KEY</code>都应该触发。为什么只要<code>Map</code>中的呢，因为如果是<code>Array</code>或者<code>json</code>时，都得通过具体<code>key</code>来访问，在<code>deps.push(depsMap.get(key))</code>就能收集到；而<code>Map</code>可以通过<code>entries</code>和<code>values</code>直接获取，所以<code>Map</code>应该关联上<code>ITERATE_KEY</code>，而<code>Set</code>数据结构并没有提供直接修改的方法所以也不需要判断。</li>
</ul>
<p>&emsp;&emsp;如果通过获取回来关联的<code>Dep</code>只有一个的话就直接触发里面所有的<code>effect</code>，如果是获取到多个<code>Dep</code>的话需要对<code>effect</code>去重，因为一个<code>effect</code>可能在一次触发中被收集多次，比如下方代码。代码中去重的方法是对所有<code>Dep（Set）</code>扩散，然后放入到一个新的<code>Dep</code>中而<code>Dep</code>是<code>Set</code>对象就会自动去重。</p>
<pre><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'key'</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> remap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>name<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> te <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>remap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>remap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
remap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">// 直接获取到key为name的dep</span>
<span class="token comment">// 获取执行remap.values方法获取到key位ITERATE_KEY的dep</span>
<span class="token comment">// 两个dep都包含map，只需要执行一次，去重</span>
</code></pre>
<p>&emsp;&emsp;到这里就已经获取到所有关联的<code>effect</code>了，然后传入到<code>triggerEffects</code>函数中，<code>triggerEffects</code>函数就是具体执行<code>effect</code>监听函数的实现，我们看看具体代码</p>
<pre><code class="language-js"><span class="token comment">// 执行因为trigger变化的所有effect</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">triggerEffects</span><span class="token punctuation">(</span>
  <span class="token parameter">dep<span class="token operator">:</span> Dep <span class="token operator">|</span> ReactiveEffect<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  debuggerEventExtraInfo<span class="token operator">?</span><span class="token operator">:</span> DebuggerEventExtraInfo</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取所有effect</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> effect <span class="token keyword">of</span> <span class="token function">isArray</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span> <span class="token operator">?</span> dep <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>dep<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果触发关联的effect 是当前正在执行的，并且没有声明允许递归则不在重复执行 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effect <span class="token operator">!==</span> activeEffect <span class="token operator">||</span> effect<span class="token punctuation">.</span>allowRecurse<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 触发onTrigger钩子</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">&amp;&amp;</span> effect<span class="token punctuation">.</span>onTrigger<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        effect<span class="token punctuation">.</span><span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span> effect <span class="token punctuation">}</span><span class="token punctuation">,</span> debuggerEventExtraInfo<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 如果当前effect有注册调度器，则使用调度器，否则则执行effect注册的函数</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        effect<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        effect<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<code>triggerEffects</code>传入参数允<code>Array</code>或<code>Dep</code>，会对所有的<code>effect</code>做一次遍历，逐一执行触发钩子、监听函数，大家注意到如果用户自定义了调度器<code>scheduler</code>的话是执行<code>scheduler</code>并不会直接执行监听函数。</p>
<p>&emsp;&emsp;当前<code>effect</code>是当前正在执行监听函数的<code>effect</code>时会有三种特殊情况：</p>
<ul>
<li><code>allowRecurse</code>为<code>false</code>则直接跳过</li>
<li><code>allowRecurse</code>为<code>true</code>没有自定义调度器时，将执行收集钩子和收集函数，但是执行监听函数前会判断当前<code>effect</code>是否在执行栈中，如果是直接跳过，所以这里只是执行了收集钩子，监听函数并没有允许递归</li>
<li><code>allowRecurse</code>为<code>true</code>有自定义调度器时，将执行钩子和自定义调度器，允许递归有效。</li>
</ul>
<p>&emsp;&emsp;<code>allowRecurse</code>对于监听函数并没有实质作用，即使声明了也不会允许递归，它是作用于<code>scheduler</code>的。</p>
<h2 id="小结">小结</h2>
<ul>
<li><strong><code>effect</code>执行收集函数时不会触发自身</strong></li>
<li><strong><code>effect</code>函数返回的是收集方法，可以显示调用</strong></li>
<li><strong><code>effect</code>函数可以传递<code>effect</code>函数返回的方法，会重新包装，但是源绑定方法是一致的</strong></li>
<li><strong><code>effect</code>监听函数中可以再调用其他收集函数，被调用者不会收集到当前<code>effect</code>的依赖</strong></li>
<li><strong>对于已经停止观察的<code>effect</code>可以在外层套一层<code>effect</code>继续监听</strong></li>
<li><strong><code>effect</code>可选参数<code>{ lazy: 懒加载, scheduler: 调度器, scope: .., allowRecurse: 是否允许递归 , onStop: 停止调度钩子, onTrack: 收集时钩子, onTragger: 触发时钩子 }</code></strong></li>
<li><strong><code>allowRecurse</code>参数是针对<code>scheduler</code>的</strong></li>
<li><strong><code>vue</code>通过<code>targetMap</code>将<code>effect</code>和收集的<code>target</code>和<code>key</code>建立关系。</strong></li>
<li><strong><code>key</code>通过<code>Dep</code>与<code>effect</code>建立关系，<code>effect</code>通过缓存<code>deps</code>与<code>key</code>建立关系</strong></li>
<li><strong><code>effect</code>的<code>deps</code>管理方式有两种，<code>effect</code>层叠数少于30时通过<code>w</code>、<code>n</code>状态细粒增删，超过<code>30</code>则进入前删，后续都是增</strong></li>
</ul>
<p>上一章：<a href="https://bill-lai.github.io/article/6452d43210bfdd32fd3c/">vue3-reactive源码解析</a><br>下一章：<a href="https://bill-lai.github.io/article/37495e00ab36e870f8dd/">vue3-ref源码解析</a></p>
</div><div class="style_article-loading-layer__3poja"><div class="style_layer__GxMiF"><div style="fill:var(--vice-color);height:64px;width:64px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle transform="translate(8 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(16 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.3"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(24 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.6"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
</svg>
</div></div></div> </div><div class="style_bottom__29qYA"><p>©2021 - bill-lai 的小站 -<a rel="noreferrer" href="https://github.com/bill-lai/bill-lai.github.io" target="_blank">站点源码</a></p><p>本站使用<a rel="noreferrer" target="_blank" href="https://react.docschina.org/docs/hooks-reference.html#usememo">ReactHook</a><a rel="noreferrer" target="_blank" href="https://www.typescriptlang.org/zh/">TypeScript</a><a rel="noreferrer" target="_blank" href="https://docs.github.com/cn/rest">githubAPI</a><a rel="noreferrer" target="_blank" href="https://simplemde.com/">SimpleMDE</a>制作</p></div></div><div class="style_right-layer__Rm9TS "><div class="style_right__3hdcL"><div class="style_right-content__F68mu"><div class="navigation"><h4 class="style_title__1aA1F">目录列表</h4><ul class="style_top-navs__3vyAr"><li class=""><span>阅读准备<!-- --> </span></li><li class=""><span>思考实现<!-- --> </span></li><li class=""><span>Dep<!-- --> </span></li><li class=""><span>effect<!-- --> </span></li><li class=""><span>track函数<!-- --> </span></li><li class=""><span>triggle 函数<!-- --> </span></li><li class=""><span>小结<!-- --> </span></li></ul></div></div></div></div></div></div></div></div>
          <script>var globalState = {"article/37495e00ab36e870f8dd":{"title":"vue3-effect源码解析","id":"37495e00ab36e870f8dd","mtime":1644899449102,"ctime":1644899321378,"issues":{"number":18,"commentsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/18/comments","reactionsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/18/reactions"},"head":null,"foot":null,"dirs":[{"leave":2,"title":"阅读准备","children":[]},{"leave":2,"title":"思考实现","children":[]},{"leave":2,"title":"Dep","children":[]},{"leave":2,"title":"effect","children":[]},{"leave":2,"title":"track函数","children":[]},{"leave":2,"title":"triggle 函数","children":[]},{"leave":2,"title":"小结","children":[]}],"body":"<h2 id=\"阅读准备\">阅读准备</h2>\n<blockquote>\n<p>本文使用的<code>vue</code>版本为<code>3.2.26</code>。在阅读 <code>effect</code> 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 <code>API</code>了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。</p>\n</blockquote>\n<p>&emsp;&emsp;通过上一章<a href=\"https://bill-lai.github.io/article/6452d43210bfdd32fd3c\">vue3-reactive源码解析</a>，可以猜想到，<code>effect</code>主要职责是存储<code>Proxy</code> <code>track</code> <em>（收集）</em>的依赖，当<code>Proxy</code> <code>triggle</code> <em>（触发）</em>后查看<code>trigger</code>是否是<code>track</code>存储的依赖，如果是的话则执行监听函数。关于<code>Proxy</code>是如何<code>track</code>和<code>triggle</code>的可以看上一章<a href=\"https://bill-lai.github.io/article/6452d43210bfdd32fd3c\">vue3-reactive源码解析</a>。</p>\n<p>&emsp;&emsp;为了方便表达，我将用户传入<code>effect</code>的回调函数统称为监听函数，由<code>effect</code>包裹后的统称为收集函数。</p>\n<p>通过文档和单例可以知道<code>effect</code>有以下特性</p>\n<ul>\n<li>传入的收集函数不会递归执行，就算当前<code>effect</code>内触发了已经收集的依赖。比如<code>effect(() =&gt; {rea.a; rea.a = 2})</code></li>\n<li><code>effect</code>函数返回的也是函数，可以直接通过返回的函数执行监听函数。</li>\n<li><code>effect</code>可以包裹<code>effect</code>返回的方法，会重新包装，当触发时会执行两次。</li>\n<li><code>effect</code>可以在监听函数中再次调用<code>effect</code>，但是里层不会收集外层监听函数的依赖，外层也不会收集到里层的依赖，比如：</li>\n</ul>\n<pre><code class=\"language-js\">  <span class=\"token keyword\">const</span> rea <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>a<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 1, 2</span>\n  <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rea<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rea<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 2, 2</span>\n  rea<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n  <span class=\"token comment\">// 3</span>\n  rea<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n</code></pre>\n<ul>\n<li><code>effect</code>第二个可选<code>json</code>参数，这个参数包含<code>lazy</code>, <code>scheduler</code>, <code>allowRecurse</code>, <code>onStop</code>, <code>onTrack</code>, <code>onTragger</code>属性<ul>\n<li><code>lazy</code>：<code>boolean</code>，是否懒加载，如果是<code>true</code>调用<code>effect</code>不会立即执行监听函数，由用户手动触发。</li>\n<li><code>scheduler</code>: <code>function</code>，被触发引起<code>effect</code>要重新收集依赖时的调度器，当传入时<code>effect</code>收到触发时不会重新执行监听函数而是执行这个<code>function</code>，由用户自己调度。</li>\n<li><code>allowRecurse</code>：是否允许递归，这个参数需要和<code>scheduler</code>配套使用，是否允许递归<code>scheduler</code>，<strong>对监听函数无效</strong>。</li>\n<li><code>onStop</code>：当<code>effect</code>被<code>stop</code> <em>（停止监听）</em>时的钩子。</li>\n<li><code>onTrack</code>：当<code>effect</code>被<code>track</code>时的钩子。</li>\n<li><code>onTrigger</code>：当<code>effect</code>被<code>trigger</code>时的钩子。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"思考实现\">思考实现</h2>\n<p>如果是我们自己编写<code>effect</code>会怎么实现呢？<a href=\"https://bill-lai.github.io/article/6452d43210bfdd32fd3c\">上一章</a>知道了<code>Proxy</code>会通过<code>track</code>函数告知我们收集到了哪个对象的哪个<code>key</code>，会通过<code>triggle</code>函数因为哪个对象的哪个<code>key</code>引起了触发。加上上面的阅读准备我们知道了<code>effect</code>大概需求</p>\n<ul>\n<li><code>track</code>只收集<code>effect</code>内的依赖，<code>trigger</code>是触发<code>effect</code>的收集函数或调度器。</li>\n<li>当<code>effect</code>收集函数被重新执行时需要清空之前收集的依赖并重新收集，因为收集的可能存在分支比如<code>if</code>，收集也是动态的。到这里是不是有大概的思路了，</li>\n</ul>\n<p>&emsp;&emsp;根据需我们可以简单的实现大概逻辑：</p>\n<p><img src=\"/article/37495e00ab36e870f8dd/./image/effect.drawio.svg\" alt=\"effect.svg\"></p>\n<p>&emsp;&emsp;在<code>vue</code>中<code>effect</code>实现的原理流程其实跟上图是差不多的，接下来我们就一份一份拆解出来看看它各个部分是怎么实现的，我们先看看<code>target</code>，<code>key</code>，<code>effect</code>的关系在里面是怎么实现的。</p>\n<h2 id=\"dep\">Dep</h2>\n<p>&emsp;&emsp;<code>vue</code>中是如何存储<code>target</code>，<code>key</code>，<code>effect</code>的关系的，在<code>effect</code>源码中我们可以看到顶部有一段代码</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// Dep: Set对象，可以存储多个effect对象</span>\n<span class=\"token keyword\">export</span> type Dep <span class=\"token operator\">=</span> Set<span class=\"token operator\">&lt;</span>ReactiveEffect<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span> TrackedMarkers\n\n<span class=\"token comment\">// Dep附加对象，用来标识effect的状态</span>\ntype TrackedMarkers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/**\n   * wasTracked\n   */</span>\n  <span class=\"token comment\">// 之前被收集</span>\n  w<span class=\"token operator\">:</span> number\n  <span class=\"token comment\">/**\n   * newTracked\n   */</span>\n  <span class=\"token comment\">// 当前被收集</span>\n  n<span class=\"token operator\">:</span> number\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// key关联Dep的Map 为了方便我们叫他kDepMap</span>\ntype KeyToDepMap <span class=\"token operator\">=</span> Map<span class=\"token operator\">&lt;</span>any<span class=\"token punctuation\">,</span> Dep<span class=\"token operator\">></span>\n<span class=\"token comment\">// Target -> kDepMap</span>\n<span class=\"token keyword\">const</span> targetMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakMap</span><span class=\"token operator\">&lt;</span>any<span class=\"token punctuation\">,</span> KeyToDepMap<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>&emsp;&emsp;在<code>effect</code>源码文件中声明了一个类型为<code>WeakMap</code>的<code>targetMap</code>变量，这个<code>targetMap</code>就是存储监听函数执行期间<code>Proxy</code>中<code>track</code>出来的依赖与<code>effect</code>。</p>\n<p>&emsp;&emsp;<code>Proxy</code>调用<code>track</code>时抛出的参数中有代理的<code>Target（raw）</code>和引起<code>track</code>的<code>key</code>，而一个<code>Target</code>可以有多个<code>key</code>引起<code>track</code>，<code>key</code>也可能是对象，因为<code>Target</code>可能是<code>Map</code>或者<code>WeakMap</code>，除了存储<code>Target</code>和<code>key</code>外，也要存储这个<code>key</code>是在哪些<code>effect</code>的监听函数中使用的，所以<code>vue</code>采用双<code>Map</code>的存储方式。<code>kDepMap</code>存储每个<code>key</code>和<code>effect</code>的引用关系，然后<code>targetMap</code>存储<code>target</code>和<code>kDepMap</code>的引用关系。</p>\n<p>&emsp;&emsp;上面还使用了<code>ts</code>为<code>Dep</code>的类型来标记<code>kDepMap</code>的<code>value</code>，<code>Dep</code>在<code>Set</code>的基础上附加值为<code>number</code>属性<code>w</code>、<code>h</code>。<code>Dep</code>中的<code>w</code>和<code>n</code>是干什么用的呢，我们看到源码中的注释<code>wasTracked</code>和<code>newTracked</code>从字面意思可以猜测出来，应该是记录之前是否被收集和现在是否被收集。我们之前讲过，数据收集是动态的，所以每次执行收集前需要清空之前的依赖，然后附加上现在的依赖，确保依赖正确，比如下方的代码：</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> reuser <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> \n  name<span class=\"token operator\">:</span> <span class=\"token string\">'bill'</span><span class=\"token punctuation\">,</span> \n  sex<span class=\"token operator\">:</span> <span class=\"token string\">'男'</span><span class=\"token punctuation\">,</span>\n  setLog<span class=\"token operator\">:</span> <span class=\"token string\">'name'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 第一次执行收集到的key是setLog、name</span>\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">[</span>reuser<span class=\"token punctuation\">.</span>setLog<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 更改后收集到的key是setLog、sex</span>\nreuser<span class=\"token punctuation\">.</span>setLog <span class=\"token operator\">=</span> <span class=\"token string\">'sex'</span>\n</code></pre>\n<p>&emsp;&emsp;<code>vue</code>中将这两个属性直接关联到<code>Dep</code>中，也就是说<code>Target</code>的每个<code>key</code>都有当前之前是否被收集、现在是否被收集的标识状态。按照平常的做法来说这种状态应该是附加到<code>effect</code>实例，因为<code>Dep</code>是<code>Set</code>它里面存储的不止是一个<code>effect</code>，每个<code>effect</code>都应该有状态，但是现在附加到了<code>Dep</code>上，也就意味着必须要对<code>Dep</code>的<code>w</code>、<code>n</code>做一些特殊的处理：</p>\n<ul>\n<li><strong>当<code>effect</code>函数执行完毕之后必须要还原<code>Dep</code>的<code>w</code>和<code>h</code>的状态，否则<code>Set</code>中其他<code>effect</code>使用就不正确了</strong></li>\n<li><strong>当<code>effect</code>函数执行前必须恢复<code>w</code>属性（之前是否被<code>trick</code>）</strong></li>\n<li><strong>当<code>effect</code>函数递归调用时，<code>w</code>和<code>h</code>属性必须能够完整记录每一层的状态</strong>，比如下方这种方式调用</li>\n</ul>\n<pre><code class=\"language-js\">  <span class=\"token keyword\">const</span> rea <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rea<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    rea<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n    <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rea<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>&emsp;&emsp;因为这些都是与<code>effect</code>中实现直接挂钩的，等我们讲到<code>effect</code>具体实现时再看看他们是怎么具体实现的。现在我们可以先思考<code>w</code>、<code>h</code>怎么实现这三点的，前两点都还好，只是恢复和还原状态，但是第三点要记录多层状态。要记录多层状态，而<code>w</code>、<code>h</code>又是<code>number</code>，可以得出结论，这两个属性是要用位运算符做多层状态管理，关于位运算符是怎么做状态的，大家可以看看我之前写的<a href=\"https://bill-lai.github.io/article/9c6d734aa72e04e0f8dd/\">这篇文章</a>。递归调用<code>effect</code>时每一层<code>effect</code>，<code>w</code>、<code>h</code>都用一个特定的位来标识这一次<code>effect</code>的状态，在二进制中的用<code>1</code>表示<code>true</code>，<code>0</code>表示<code>false</code>这是常规做法。在<code>vue</code>中使用的是从第二位开始标记当前状态，每多一层就将当前标识状态的往前推一位，例如：</p>\n<pre><code class=\"language-js\">  <span class=\"token keyword\">const</span> rea <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  \n  <span class=\"token comment\">//初次生成</span>\n  <span class=\"token comment\">// key: a</span>\n  <span class=\"token comment\">// Dep: { w: 0, n: 0 }</span>\n  <span class=\"token comment\">//   w.toString(2): 00000000000000000000000000000000</span>\n  <span class=\"token comment\">//   n.toString(2): 00000000000000000000000000000000</span>\n  <span class=\"token comment\">//</span>\n  <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//第一次收集</span>\n    <span class=\"token comment\">//  key: a</span>\n    <span class=\"token comment\">//  Dep: { w: 0, n: 2 }</span>\n    <span class=\"token comment\">//    w.toString(2): 00000000000000000000000000000000</span>\n    <span class=\"token comment\">//    n.toString(2): 00000000000000000000000000000010</span>\n    <span class=\"token comment\">//第二次收集，恢复已经被收集状态</span>\n    <span class=\"token comment\">//  key: a</span>\n    <span class=\"token comment\">//  Dep: { w: 2, n: 2 }</span>\n    <span class=\"token comment\">//    w.toString(2): 00000000000000000000000000000010</span>\n    <span class=\"token comment\">//    n.toString(2): 00000000000000000000000000000010</span>\n    <span class=\"token comment\">//</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rea<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 进入内层</span>\n      <span class=\"token comment\">// 第一次收集</span>\n      <span class=\"token comment\">//   key: a</span>\n      <span class=\"token comment\">//   Dep: { w: 0, n: 6 }</span>\n      <span class=\"token comment\">//     w.toString(2): 00000000000000000000000000000000</span>\n      <span class=\"token comment\">//     n.toString(2): 00000000000000000000000000000110</span>\n      <span class=\"token comment\">// 第二次收集，恢复已经被收集状态</span>\n      <span class=\"token comment\">//   key: a</span>\n      <span class=\"token comment\">//   Dep: { w: 6, n: 6 }</span>\n      <span class=\"token comment\">//     w.toString(2): 00000000000000000000000000000110</span>\n      <span class=\"token comment\">//     n.toString(2): 00000000000000000000000000000110</span>\n      <span class=\"token comment\">//</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rea<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span>\n\n     <span class=\"token comment\">//离开外层清空恢复进入状态</span>\n     <span class=\"token comment\">//第一次收集离开</span>\n     <span class=\"token comment\">// key: a</span>\n     <span class=\"token comment\">// Dep: { w: 0, n: 2 }</span>\n     <span class=\"token comment\">//   w.toString(2): 00000000000000000000000000000000</span>\n     <span class=\"token comment\">//   n.toString(2): 00000000000000000000000000000010</span>\n     <span class=\"token comment\">//第二次收集离开</span>\n     <span class=\"token comment\">// key: a</span>\n     <span class=\"token comment\">// Dep: { w: 2, n: 2 }</span>\n     <span class=\"token comment\">//   w.toString(2): 00000000000000000000000000000010</span>\n     <span class=\"token comment\">//   n.toString(2): 00000000000000000000000000000010</span>\n     <span class=\"token comment\">//</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">//离开外层清空恢复进入状态</span>\n    <span class=\"token comment\">//  key: a</span>\n    <span class=\"token comment\">//  Dep: { w: 0, n: 0 }</span>\n    <span class=\"token comment\">//    w.toString(2): 00000000000000000000000000000000</span>\n    <span class=\"token comment\">//    n.toString(2): 00000000000000000000000000000000</span>\n    <span class=\"token comment\">//</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  rea<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n</code></pre>\n<p>&emsp;&emsp;要标识当前递归调用了多少次，还需要用一个变量来记录，在<code>effect</code>中使用<code>effectTrackDepth</code>变量来记录，现在来看看<code>Dep</code>的具体管理方法：</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// -----effect文件中------</span>\n<span class=\"token comment\">// 当前effect层叠数</span>\n<span class=\"token keyword\">let</span> effectTrackDepth <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token comment\">// 当前trick需要操作的bit</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> trackOpBit <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\">// 在使用时 trackOpBit = 1 &lt;&lt; ++effectTrackDepth</span>\n<span class=\"token comment\">// 也就是effect递归多少次就往前推多少位</span>\n<span class=\"token comment\">// effectTrackDepth = 0    trackOpBit = 00000000000000000000000000000010</span>\n<span class=\"token comment\">// effectTrackDepth = 1    trackOpBit = 00000000000000000000000000000100</span>\n<span class=\"token comment\">// effectTrackDepth = 2    trackOpBit = 00000000000000000000000000001000</span>\n<span class=\"token comment\">// effectTrackDepth = 3    trackOpBit = 00000000000000000000000000010000</span>\n<span class=\"token comment\">// ----------------------</span>\n\n<span class=\"token comment\">// 创建dep</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> createDep <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>effects<span class=\"token operator\">?</span><span class=\"token operator\">:</span> ReactiveEffect<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token parameter\">Dep</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token operator\">&lt;</span>ReactiveEffect<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>effects<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> Dep\n  <span class=\"token comment\">// 初始化</span>\n  dep<span class=\"token punctuation\">.</span>w <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  dep<span class=\"token punctuation\">.</span>n <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">return</span> dep\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 传入的Dep 查看当关联key在effect中之前是否被track</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> wasTracked <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>dep<span class=\"token operator\">:</span> Dep<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token parameter\">boolean</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">.</span>w <span class=\"token operator\">&amp;</span> trackOpBit<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\">// 传入的Dep 查看当关联key在effect中现在是否被track</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> newTracked <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>dep<span class=\"token operator\">:</span> Dep<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token parameter\">boolean</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">.</span>n <span class=\"token operator\">&amp;</span> trackOpBit<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span>\n</code></pre>\n<p>&emsp;&emsp;为了方便操作<code>vue</code>会创建一个<code>trackOpBit</code>变量，这个变量根据当前<code>effect</code>的递归往前推进，保证<code>trackOpBit</code>的二进制位数中为<code>1</code>的位置和<code>w</code>、<code>h</code>二进制数标识当前<code>effect</code>状态的位置是保持一致的。当需要判断<code>key</code>在当前<code>effect</code>之前和现在是否被收集时只需要<code>dep.w &amp; trackOpBit</code>和<code>dep.n &amp; trackOpBit</code>是否大于<code>0</code>就行了，如果对于 <code>&amp;</code>运算符不了解可以看看我之前写的<a href=\"https://bill-lai.github.io/article/9c6d734aa72e04e0f8dd/\">这篇文章</a>。</p>\n<p>&emsp;&emsp;通过<code>Dep</code>记录的这某个<code>key</code>上一次是否被收集和现在是否被收集，我们可以猜测到<code>vue</code>是怎么管理<code>targetMap</code>的了，<code>vue</code>中重新收集时 <em>（即调用<code>effect</code>监听函数）</em>可能不是简单粗暴的直接剔除<code>KeyToDepMap</code>中<code>Set</code>所有当前的<code>effect</code>，然后再收集，而是：</p>\n<ul>\n<li><strong>之前<code>key</code>被收集，但是当前没有收集，则在<code>key</code>关联的<code>Dep</code>中剔除当前<code>effect</code></strong></li>\n<li><strong>之前<code>key</code>没有被收集，当时当前被收集<code>，则在</code>key<code>关联的</code>Dep<code>中添加当前</code>effect`</strong></li>\n<li><strong>之前<code>key</code>被收集，当前也被收集，则保持不变</strong></li>\n</ul>\n<h2 id=\"effect\">effect</h2>\n<p>&emsp;&emsp;接下来我们看看<code>effect</code>函数的具体代码</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> extend <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span>assign\n<span class=\"token comment\">// 创建effect函数</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> effect<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token operator\">=</span> any<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  options<span class=\"token operator\">?</span><span class=\"token operator\">:</span> ReactiveEffectOptions\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ReactiveEffectRunner <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 如果当前fn已经是收集函数包装后的函数，则获取监听函数当做入参</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fn <span class=\"token keyword\">as</span> ReactiveEffectRunner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fn <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fn <span class=\"token keyword\">as</span> ReactiveEffectRunner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span>fn\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 创建effect对象</span>\n  <span class=\"token keyword\">const</span> _effect <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReactiveEffect</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 将用户传入的参数附加到effect对象上</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>_effect<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 如果有定义域作用于则记录，这个我们后面章节再讲，这里不影响主流程</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>scope<span class=\"token punctuation\">)</span> <span class=\"token function\">recordEffectScope</span><span class=\"token punctuation\">(</span>_effect<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">.</span>scope<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 如果不是懒加载则立即执行包装后的监听函数</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>options <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>options<span class=\"token punctuation\">.</span>lazy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _effect<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 绑定收集函数的this对象，和effect对象</span>\n  <span class=\"token keyword\">const</span> runner <span class=\"token operator\">=</span> _effect<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>_effect<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> ReactiveEffectRunner\n  runner<span class=\"token punctuation\">.</span>effect <span class=\"token operator\">=</span> _effect\n  <span class=\"token keyword\">return</span> runner\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>effect</code>函数主要是创建<code>ReactiveEffect</code>对象，将用户传入的参数附加到对象上，履行<code>lazy</code>参数的职责。</p>\n<p>&emsp;&emsp;<code>effect</code>返回的是<code>effect.run</code>函数，这个函数的<code>effect</code>属性会指向<code>effect</code>对象，<code>this</code>也会设置为<code>effect</code>对象。所以当懒加载时，或者用户主动执行<code>effect</code>包装后的监听函数，也能够正确的<code>track</code>。</p>\n<!-- &emsp;&emsp;`effect.run()`函数主要是设置`currentEffect`让`track`可以被正常设置，并清空之前存储的映射关系。 -->\n\n<p>&emsp;&emsp;我们看到入参时会查看监听函数是否是<code>effect</code>包装后的函数，如果是会拿到未包装前的监听函数 <em>（存储再<code>effect</code>对象的<code>fn</code>属性上）</em>再创建<code>effect</code>，所以**<code>effect</code>可以包裹<code>effect</code>返回的方法，会重新包装，当触发时会执行两次。**</p>\n<p>&emsp;&emsp;这里<code>ReactiveEffect</code>采用了<code>class</code>写法，每个<code>effect</code>函数都会创建一个实例，接下来我们看看这个<code>class</code>的具体代码</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// 最多30个互相引用，如果超出则清理</span>\n<span class=\"token keyword\">const</span> maxMarkerBits <span class=\"token operator\">=</span> <span class=\"token number\">30</span>\n<span class=\"token comment\">// 正在执行的effect栈</span>\n<span class=\"token keyword\">const</span> effectStack<span class=\"token operator\">:</span> ReactiveEffect<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// 当前正在执行的effect</span>\n<span class=\"token keyword\">let</span> activeEffect<span class=\"token operator\">:</span> ReactiveEffect <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span>\n\n<span class=\"token keyword\">let</span> effectTrackDepth <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\">// effect对象</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReactiveEffect</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token operator\">=</span> any<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 当前对象是否是有效的，为false则是已加stop的了</span>\n  active <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token comment\">// 记录当前effect 收集到的所有key对应的Dep</span>\n  deps<span class=\"token operator\">:</span> Dep<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token comment\">// 是否是computed 创建后可以附加</span>\n  computed<span class=\"token operator\">?</span><span class=\"token operator\">:</span> boolean\n  <span class=\"token comment\">// 是否允许递归响应</span>\n  allowRecurse<span class=\"token operator\">?</span><span class=\"token operator\">:</span> boolean\n  <span class=\"token comment\">// 停止监听钩子</span>\n  onStop<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span>\n  <span class=\"token comment\">// 被收集时钩子</span>\n  onTrack<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token operator\">:</span> DebuggerEvent</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span>\n  <span class=\"token comment\">// 被触发时钩子</span>\n  onTrigger<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token operator\">:</span> DebuggerEvent</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span>\n\n  <span class=\"token comment\">// 构造函数</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">// 监听函数</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 调度器</span>\n    <span class=\"token keyword\">public</span> scheduler<span class=\"token operator\">:</span> EffectScheduler <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 作用域</span>\n    scope<span class=\"token operator\">?</span><span class=\"token operator\">:</span> EffectScope <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 记录当前对象的空间范围</span>\n    <span class=\"token function\">recordEffectScope</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> scope<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 收集函数</span>\n  <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果当前effect已经被stop</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>active<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 直接监听函数，不做收集逻辑</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 查看当前调度栈是否包含当前对象，如果包含说明是嵌套运行，不再执行</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>effectStack<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 当前effect入栈</span>\n        effectStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>activeEffect <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// 开启收集</span>\n        <span class=\"token function\">enableTracking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\">// 根据层叠数更改trackOpBit</span>\n        trackOpBit <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">++</span>effectTrackDepth\n\n        <span class=\"token comment\">// 查看当前effect层叠数是否超过允许的最大记录数</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effectTrackDepth <span class=\"token operator\">&lt;=</span> maxMarkerBits<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 记录恢复上一次dep状态 也就是更改w</span>\n          <span class=\"token function\">initDepMarkers</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 如果超过了最大bit记录数，则清除当前effect关联的所有Dep映射</span>\n          <span class=\"token function\">cleanupEffect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 如果当前effect轮询个数没超限制</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effectTrackDepth <span class=\"token operator\">&lt;=</span> maxMarkerBits<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 整理effect deps 删除失效无用的dep, 恢复 dep w n状态</span>\n          <span class=\"token function\">finalizeDepMarkers</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 恢复执行位数</span>\n        trackOpBit <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">--</span>effectTrackDepth\n\n        <span class=\"token comment\">// 恢复收集状态</span>\n        <span class=\"token function\">resetTracking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// 出栈</span>\n        effectStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// 将正在使用effect替换成栈顶</span>\n        <span class=\"token keyword\">const</span> n <span class=\"token operator\">=</span> effectStack<span class=\"token punctuation\">.</span>length\n        activeEffect <span class=\"token operator\">=</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> effectStack<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 停止监听</span>\n  <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>active<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 清除当前effect关联的所有Dep映射</span>\n      <span class=\"token function\">cleanupEffect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onStop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>active <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;关于<code>computed</code>、<code>scope</code>和<code>recordEffectScope</code>我们后面的章节再讲，这里不会影响当前业务，先忽略它们。</p>\n<p>&emsp;&emsp;<code>effect</code>函数传入的参数都会附加到<code>ReactiveEffect</code>对象上，其中<code>scheduler</code>可以通过构造函数传入。<code>effect</code>对象上还会附加<code>deps</code>属性，这个属性是记录<code>effect</code>关联的所有<code>key</code>的<code>Dep</code>对象。这里附加是因为响应式对象不止只有<code>reactive</code>, 还有其他响应式对象的依赖需要存储，其他响应式对象我们后面再讲。还有一方面是为了方便的管理，比如在执行前会还原当前<code>Dep</code>在之前是否被收集，执行完毕后需要对当前关联的所有<code>Dep</code>还原状态，停止监听时直接通过关联的<code>dep</code>删除<code>effect</code>。</p>\n<p>&emsp;&emsp;在<code>effect</code>对象中使用<code>run</code>方法执行监听方法和附加状态。当<code>effect</code>对象被停用时调用<code>run</code>方法只是执行监听方法。</p>\n<p>&emsp;&emsp;当进入收集函数时会进行检测当前对象是否已经在执行栈内，如果在栈内则中断执行，我们可以看到<code>allowRecurse</code>参数并没有在这里使用上，所以即使声明了<code>allowRecurse</code>参数对于收集函数的递归也是没什么效果。</p>\n<p>&emsp;&emsp;正式进入会将正在执行的<code>effect</code>对象替换成当前<code>effect</code>对象，并且入栈。当在一个收集函数内调用另一个收集函数时时会叠加<code>effectTrackDepth</code>变量。还有我们之前说的<code>trackOpBit</code>变量，确保<code>trackOpBit</code>的中<code>1</code>的位数是跟<code>Dep</code>的<code>w</code>、<code>h</code>标识当前<code>effect</code>的位置是一致的，这样就能正确的使用<code>wasTracked</code>和<code>newTracked</code>方法。</p>\n<p>&emsp;&emsp;收集函数还有个最大叠层数限制这个层叠数是30，在<code>maxMarkerBits</code>中声明。在<code>js</code>中<code>number</code>中使用32位的二进制数来表示数字的，第32位是符号位（0为正，1为负），那就是说最多能表示31个状态，而在<code>w</code>、<code>n</code>中最后一位没有使用，第一次进去是使用<code>1 &lt;&lt; 1</code>，直接从第二位开始的。所以最大的层数只能是<code>30</code>。</p>\n<p>&emsp;&emsp;执行收集函数时是怎么恢复上次是否被收集的状态呢，因为每个<code>effect</code>对象都记录了<code>key</code>关联上的<code>dep</code>（ *<code>deps</code>*），当最新进入时，这些<code>Dep</code>就是上次的收集值，如果当前层叠数没超过30次，只需要在最新执行前将这些<code>dep</code>都打上之前被收集的标记就行了，在收集函数中使用<code>initDepMarkers</code>函数来实现的，下面我们看看源码</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// 初始effect dep 的 记录</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">initDepMarkers</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> deps <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> ReactiveEffect</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> deps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      deps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>w <span class=\"token operator\">|=</span> trackOpBit <span class=\"token comment\">// set was tracked</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;如果层叠数超过30次呢？这时候<code>w</code>，<code>h</code>无法正确的记录状态了，要怎么正确的收集和更新<code>dep</code>呢？因为无法记录状态，所以不知道之前是否收集过，那么就执行简单粗暴的方法，直接将之前<code>effect</code>对象收集的<code>Dep</code>删除掉，并删掉<code>Dep</code>中<code>effect</code>对象的引用，那新增加的就一定是正确的，这样就绕过需要状态的问题了。在<code>effect</code>是通过<code>cleanupEffect</code>方法清空当前<code>effect</code>对象与<code>Dep</code>的互相引用的，我们看看实现这个方法的实现</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// 清空当前effect对象与Dep的互相引用的</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">cleanupEffect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">effect<span class=\"token operator\">:</span> ReactiveEffect</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> deps <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> effect\n  <span class=\"token comment\">// 清除Dep中effect的引用</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> deps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      deps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>effect<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    deps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;到这我们就看完了执行前的准备就已经完成，现在看看执行后effect的deps和Dep对象的处理是怎么处理的。</p>\n<ul>\n<li><p>如果已经超过最大层叠数，则<code>effect</code>的<code>deps</code>和<code>Dep</code>不需要做任何处理，因为之前收集的<code>Dep</code>已经被删除了，现在存下来的肯定是最新，而且也没用到<code>Dep</code>的<code>w</code>和<code>n</code>状态。</p>\n</li>\n<li><p>如果没超过最大层叠数，<code>Dep</code>的<code>w</code>和<code>n</code>因为是被多个<code>effect</code>对象引用，所以执行后要恢复到进入时的状态，确保其他<code>effect</code>对象使用时是正确的。为什么不能直接还原到最初的状态 *(<code>{w: 0, n: 0}</code>)*，因为收集函数可能互相引入，当前收集函数执行完，执行权还要交还给上一个收集函数，要确保上一个收集函数内的<code>w</code>、<code>h</code>状态正确。除了恢复状态我们还要更新<code>effect</code>对象的<code>deps</code>属性，在执行前都打上了被收集的标识，那么执行后只需要查看<code>key</code>关联的<code>Dep</code>现在是否被收集就能判断是需要删除或保留 <em>（添加是在<code>trick</code>方法进行的）</em>。在<code>vue</code>中是使用<code>finalizeDepMarkers</code>函数来管理这部分需求的，接下来我们看看实现：</p>\n</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"token comment\">// 更新effect对象的deps属性</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">finalizeDepMarkers</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">effect<span class=\"token operator\">:</span> ReactiveEffect</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取deps</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> deps <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> effect\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> ptr <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> deps<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> dep <span class=\"token operator\">=</span> deps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n      <span class=\"token comment\">// 如果之前dep已经收集，但是当前没有被收集，直接删除</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">wasTracked</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">newTracked</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        dep<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>effect<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 更新deps</span>\n        deps<span class=\"token punctuation\">[</span>ptr<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dep\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// clear bits</span>\n      <span class=\"token comment\">// 清除dep在这次收集函数中的状态</span>\n      dep<span class=\"token punctuation\">.</span>w <span class=\"token operator\">&amp;=</span> <span class=\"token operator\">~</span>trackOpBit\n      dep<span class=\"token punctuation\">.</span>n <span class=\"token operator\">&amp;=</span> <span class=\"token operator\">~</span>trackOpBit\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 更新deps</span>\n    deps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> ptr\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>  如果之前收集过但是现在没收集的则直接删除，否则就保留，并且每个<code>dep</code>中标识当前<code>effect</code>状态的位标识符都重置为进入时的状态。这个函数通过记录当前保留的总数，然后要删除的<code>dep</code>的位置替换成要保留的<code>dep</code>，最后更新<code>length</code>，写的也是相当精妙。</p>\n<p>&emsp;&emsp;在恢复<code>dep</code>状态和更新<code>effect</code>对象的<code>deps</code>后，也会将当前<code>trackOpBit</code>、<code>activeEffect</code>、<code>effectStack</code>恢复到进入前状态。到这里收集方法就已经看完了，接下来我们看看实例上的另外一个方法<code>stop</code>，这个方法相对比较简单，只是清空<code>targetMap</code>中当前<code>effect</code>对象引用，调用停用钩子，并更改当前<code>effect</code>对象的状态 <em>（<code>active</code>）</em>为已经被停用。<code>effect</code>中还为这个方法对外提供了一个主动调起的辅助方法<code>stop</code>:</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">runner<span class=\"token operator\">:</span> ReactiveEffectRunner</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  runner<span class=\"token punctuation\">.</span>effect<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;到这里<code>effect</code>对象里面具体的实现已经讲完了，那<code>track</code>又是怎么存储<code>effect</code>到<code>Dep</code>的，又是怎么将<code>effect</code>和<code>Dep</code>两者关联的呢，接下来让我们探索<code>track</code>里的具体实现。</p>\n<h2 id=\"track函数\">track函数</h2>\n<p>&emsp;&emsp;让我们回顾一下之前内容，<code>track</code>函数是在<code>Proxy</code>的基础拦截器或者是集合修改器中获取数据时触发的，主要是关联<code>effect</code>跟收集到的依赖，接下来我们看看<code>track</code>函数的具体实现，先看看具体代码</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// 当前是否正在收集，当前开启收集，并且有正在使用的effect对象</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">isTracking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> shouldTrack <span class=\"token operator\">&amp;&amp;</span> activeEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 收集effect对象的依赖建立关系</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">track</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">target<span class=\"token operator\">:</span> object<span class=\"token punctuation\">,</span> type<span class=\"token operator\">:</span> TrackOpTypes<span class=\"token punctuation\">,</span> key<span class=\"token operator\">:</span> unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 如果当前没有进行收集则直接返回</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isTracking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 获取 KeyToDepMap（keys -> Dep）</span>\n  <span class=\"token keyword\">let</span> depsMap <span class=\"token operator\">=</span> targetMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 如果不存在则初始化KeyToDepMap</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>depsMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    targetMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>depsMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 获取当前 key的Dep</span>\n  <span class=\"token keyword\">let</span> dep <span class=\"token operator\">=</span> depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 如果不存在则创建Dep</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>dep <span class=\"token operator\">=</span> <span class=\"token function\">createDep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 如果是开发环境则记录具体信息</span>\n  <span class=\"token keyword\">const</span> eventInfo <span class=\"token operator\">=</span> __DEV__\n    <span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span> effect<span class=\"token operator\">:</span> activeEffect<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> key <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span>\n\n  <span class=\"token function\">trackEffects</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">,</span> eventInfo<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>track</code>函数的逻辑并不复杂，首先检测当前是否正在收集，这个判断就是当前<code>trackStack</code>栈顶是开启了收集，并且当前正在执行收集函数，如果不是正在收集则直接退出，确保只有正在执行收集函数时才能进入。然后查看映射关系中是否存在当前<code>Target</code>的<code>KeyToDepMap（keys -&gt; Dep）</code>如果不存在则创建，在通过<code>key</code>查找是否有<code>Dep</code>没有则创建。如果是开发环境还会创建需要附加到钩子的具体收集信息，最后调用<code>trackEffects</code>方法，可以猜测得到<code>trackEffects</code>才是真正实现具体业务的方法。</p>\n<p>&emsp;&emsp;下面我们看看<code>trackEffects</code>的具体实现代码：</p>\n<pre><code class=\"language-js\">\n<span class=\"token comment\">// track，更改Dep状态，更新effect对象的deps</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">trackEffects</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">dep<span class=\"token operator\">:</span> Dep<span class=\"token punctuation\">,</span>\n  debuggerEventExtraInfo<span class=\"token operator\">?</span><span class=\"token operator\">:</span> DebuggerEventExtraInfo</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 是否是新增的依赖</span>\n  <span class=\"token keyword\">let</span> shouldTrack <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token comment\">// 查看当前层叠数是否能超过了记录的最大限制</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effectTrackDepth <span class=\"token operator\">&lt;=</span> maxMarkerBits<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 查看是否记录过当前依赖</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">newTracked</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 记录是当前收集的依赖</span>\n      dep<span class=\"token punctuation\">.</span>n <span class=\"token operator\">|=</span> trackOpBit <span class=\"token comment\">// set newly tracked</span>\n      <span class=\"token comment\">// 如果effect之前已经收集过，则不是新增依赖</span>\n      shouldTrack <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token function\">wasTracked</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果层叠数超过了最大，则查看当前dep在effect中实收存储过</span>\n    <span class=\"token comment\">// 因为超过最大进入前会清空所有dep，</span>\n    <span class=\"token comment\">// 第一次进入一定会收集，当收集重复key时才会跳过</span>\n    shouldTrack <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>dep<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>activeEffect<span class=\"token operator\">!</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 如果是新增的收集</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shouldTrack<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// dep添加当前正在使用的effect</span>\n    dep<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>activeEffect<span class=\"token operator\">!</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// effect的deps也记录当前dep 双向引用</span>\n    activeEffect<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span>deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 如果当前是开发环境，还要执行onTrack钩子</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__ <span class=\"token operator\">&amp;&amp;</span> activeEffect<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span>onTrack<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      activeEffect<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span><span class=\"token function\">onTrack</span><span class=\"token punctuation\">(</span>\n        Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>\n          <span class=\"token punctuation\">{</span>\n            effect<span class=\"token operator\">:</span> activeEffect<span class=\"token operator\">!</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          debuggerEventExtraInfo\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;没超过最大层叠数时，收集函数收集到的<code>Dep</code>需要打上当前被收集的状态，给<code>effect</code>对象执行完毕后更新<code>deps</code>属性使用性。如果当前收集到了<code>dep</code>，但是之前不存在，说明这个<code>dep</code>是新增的。当超过最大层叠数时执行前就清空之前的所有<code>Dep</code>中当前<code>effect</code>对象的引用，所以当进入收集函数时所有<code>dep</code>就都是新增的。新增的<code>dep</code>时需要将当前<code>effect</code>添加到这个<code>Dep</code>中，并且将这个<code>dep</code>添加到当前<code>effect</code>的deps中，然后触发收集钩子。</p>\n<p>&emsp;&emsp;到这里<code>track</code>函数里面具体的实现已经讲完了，<code>effect</code>通过监听函数执行前设置当前<code>effect</code>，并使用<code>Dep</code>的<code>w</code>和<code>n</code>属性标记状态，然后在<code>track</code>中使用，通过这种方式确定当前是否在<code>effect</code>内收集到的依赖，确定状态，更新状态。</p>\n<h2 id=\"triggle-函数\">triggle 函数</h2>\n<p>&emsp;&emsp;接下来我们看看<code>triggle</code>函数是如何通过<code>target</code>，<code>key</code>和<code>targetMap</code>存储库确定要执行的收集函数。</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// trigger 值变化</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">trigger</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">target<span class=\"token operator\">:</span> object<span class=\"token punctuation\">,</span>\n  type<span class=\"token operator\">:</span> TriggerOpTypes<span class=\"token punctuation\">,</span>\n  key<span class=\"token operator\">?</span><span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">,</span>\n  newValue<span class=\"token operator\">?</span><span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">,</span>\n  oldValue<span class=\"token operator\">?</span><span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">,</span>\n  oldTarget<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span>unknown<span class=\"token punctuation\">,</span> unknown<span class=\"token operator\">></span> <span class=\"token operator\">|</span> Set<span class=\"token operator\">&lt;</span>unknown<span class=\"token operator\">></span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取当前target的KeyToDepMap</span>\n  <span class=\"token keyword\">const</span> depsMap <span class=\"token operator\">=</span> targetMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>depsMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// never been tracked</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 需要触发的deps</span>\n  <span class=\"token keyword\">let</span> deps<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Dep <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">===</span> TriggerOpTypes<span class=\"token punctuation\">.</span><span class=\"token constant\">CLEAR</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 如果是清除当前数据（Set和Map中的操作），那所有dep都应该触发</span>\n    deps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">===</span> <span class=\"token string\">'length'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果是修改数组长度，</span>\n    <span class=\"token comment\">// length和被删除的下标的key 关联的dep都应该被触发</span>\n    depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">dep<span class=\"token punctuation\">,</span> key</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">===</span> <span class=\"token string\">'length'</span> <span class=\"token operator\">||</span> key <span class=\"token operator\">>=</span> <span class=\"token punctuation\">(</span>newValue <span class=\"token keyword\">as</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 先获取当前key关联的deps</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!==</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// also run for iteration key on ADD | DELETE | Map.SET</span>\n    <span class=\"token comment\">// 判别操作类型，</span>\n    <span class=\"token comment\">// 有些操作会关联到其他操作，需要分别判断</span>\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 如果是增加操作</span>\n      <span class=\"token keyword\">case</span> TriggerOpTypes<span class=\"token punctuation\">.</span><span class=\"token constant\">ADD</span><span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 数组需要单独判断，之前我们说过数组的迭代收集到的key是length</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 因为是新增，获取迭代收集的dep</span>\n          deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ITERATE_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isMap</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 如果是map还需要收集MAP_KEY_ITERATE_KEY</span>\n            deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">MAP_KEY_ITERATE_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isIntegerKey</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 如果是数组新增下标那么length一定会修改</span>\n          deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'length'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">break</span>\n\n      <span class=\"token comment\">// 如果是删除操作</span>\n      <span class=\"token keyword\">case</span> TriggerOpTypes<span class=\"token punctuation\">.</span><span class=\"token constant\">DELETE</span><span class=\"token operator\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 删除迭代都需要重新执行</span>\n          deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ITERATE_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isMap</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">MAP_KEY_ITERATE_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 因为删除操作一定会有length属性的变化，会引起length的triggle，这里就不需要重复收集</span>\n        <span class=\"token keyword\">break</span>\n      <span class=\"token comment\">// 如果是更改</span>\n      <span class=\"token keyword\">case</span> TriggerOpTypes<span class=\"token punctuation\">.</span><span class=\"token constant\">SET</span><span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 用户可能直接获取map.values或者 map.entries直接拿到value</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isMap</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          deps<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>depsMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">ITERATE_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">break</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 附加trigger调试信息给onTrigger钩子使用</span>\n  <span class=\"token keyword\">const</span> eventInfo <span class=\"token operator\">=</span> __DEV__\n    <span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span> target<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">,</span> oldValue<span class=\"token punctuation\">,</span> oldTarget <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span>\n\n  <span class=\"token comment\">// 假如只有一个Dep依赖则直接triggerEffects</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">triggerEffects</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> eventInfo<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">triggerEffects</span><span class=\"token punctuation\">(</span>deps<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 假如有多个deps需要对内部的effect做一遍去重</span>\n    <span class=\"token keyword\">const</span> effects<span class=\"token operator\">:</span> ReactiveEffect<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> dep <span class=\"token keyword\">of</span> deps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        effects<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>dep<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">triggerEffects</span><span class=\"token punctuation\">(</span><span class=\"token function\">createDep</span><span class=\"token punctuation\">(</span>effects<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> eventInfo<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">triggerEffects</span><span class=\"token punctuation\">(</span><span class=\"token function\">createDep</span><span class=\"token punctuation\">(</span>effects<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>trigger</code>不仅只是获取<code>get</code>在<code>targetMap</code>指定<code>key</code>的<code>Dep</code>，因为数据操作中有很多关联性的东西，比如新增和删除都需要重新触发迭代操作，下面我们详细分析各个操作的关联性。</p>\n<ul>\n<li>当<code>Map</code>执行<code>clear</code>时，需要触发所有之前收集的effect</li>\n<li>当<code>Array</code>更新<code>length</code>时，之前收集到<code>length</code>值大于当前<code>length</code>值，那么存储库中之前收集到的下标小于等于当前<code>length</code>的<code>key</code>关联的<code>Dep</code>需要重新触发，因为有可能之前有值，现在值被删除；为什么是有可能呢因为当收集到超出边界的下标时更改<code>length</code>也会重复触发，例如：</li>\n</ul>\n<pre><code class=\"language-js\">  <span class=\"token keyword\">const</span> rearr <span class=\"token operator\">=</span> <span class=\"token function\">reactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> any<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rearr<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>rearr<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  rearr<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 1 undefined </span>\n  <span class=\"token comment\">// undefined undefined</span>\n</code></pre>\n<ul>\n<li>当添加数据时，所有依赖函数收集到<code>key</code>为<code>ITERATE_KEY</code>、<code>Target</code>为<code>Map</code>中<code>Key</code>为<code>MAP_KEY_ITERATE_KEY</code>和<code>Target</code>为<code>Arrat</code>的<code>key</code>为<code>length</code>都应该触发，前两个很好理解，添加自然迭代就需要触发，但是第三个不是添加也会更改<code>length</code>吗，为什么也需要触发呢？这是因为当使用<code>api</code>时底层里面会先添加数据，这时数据内的<code>length</code>直接就被更改了，当拦截到<code>length</code>更改时已经获取不到旧值，前面我们看<code>Proxy</code>的<code>set</code>处理器触发前会做一条判断，那就是只有<code>key</code>的<code>value</code>更改了才会触发，这里<code>length</code>始终不会触发，因为始终是一致，所以当添加时就应该要触发。</li>\n</ul>\n<pre><code class=\"language-js\">  <span class=\"token keyword\">const</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    target<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nt<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 4 4 undefined</span>\n<span class=\"token comment\">// length 5 5</span>\nt<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 5 4 undefined</span>\n<span class=\"token comment\">// 4 5 4</span>\n<span class=\"token comment\">// length 6 6</span>\n</code></pre>\n<ul>\n<li>当删除数据时，所有依赖函数收集到<code>key</code>为<code>ITERATE_KEY</code>、<code>Target</code>为<code>Map</code>中<code>Key</code>为<code>MAP_KEY_ITERATE_KEY</code>都应该触发，为什么这里就不需要触发<code>Target</code>为<code>Array</code>key为<code>length</code>的<code>effect</code>，这是因为底层删除数组某项时都是通过更改<code>length</code>来实现，能够获取到旧值，当<code>length</code>新旧值发生更改时能够<code>trigger</code>所以就不需要重复收集了。</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"token operator\">...</span>\nt<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nt<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// length 3 4</span>\n<span class=\"token comment\">// length 3 3</span>\n</code></pre>\n<ul>\n<li>当更改数据时，所有依赖收集到<code>Map</code>中<code>key</code>为<code>ITERATE_KEY</code>都应该触发。为什么只要<code>Map</code>中的呢，因为如果是<code>Array</code>或者<code>json</code>时，都得通过具体<code>key</code>来访问，在<code>deps.push(depsMap.get(key))</code>就能收集到；而<code>Map</code>可以通过<code>entries</code>和<code>values</code>直接获取，所以<code>Map</code>应该关联上<code>ITERATE_KEY</code>，而<code>Set</code>数据结构并没有提供直接修改的方法所以也不需要判断。</li>\n</ul>\n<p>&emsp;&emsp;如果通过获取回来关联的<code>Dep</code>只有一个的话就直接触发里面所有的<code>effect</code>，如果是获取到多个<code>Dep</code>的话需要对<code>effect</code>去重，因为一个<code>effect</code>可能在一次触发中被收集多次，比如下方代码。代码中去重的方法是对所有<code>Dep（Set）</code>扩散，然后放入到一个新的<code>Dep</code>中而<code>Dep</code>是<code>Set</code>对象就会自动去重。</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'key'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> remap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> te <span class=\"token operator\">=</span> <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>remap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>remap<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nremap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 直接获取到key为name的dep</span>\n<span class=\"token comment\">// 获取执行remap.values方法获取到key位ITERATE_KEY的dep</span>\n<span class=\"token comment\">// 两个dep都包含map，只需要执行一次，去重</span>\n</code></pre>\n<p>&emsp;&emsp;到这里就已经获取到所有关联的<code>effect</code>了，然后传入到<code>triggerEffects</code>函数中，<code>triggerEffects</code>函数就是具体执行<code>effect</code>监听函数的实现，我们看看具体代码</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">// 执行因为trigger变化的所有effect</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">triggerEffects</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">dep<span class=\"token operator\">:</span> Dep <span class=\"token operator\">|</span> ReactiveEffect<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  debuggerEventExtraInfo<span class=\"token operator\">?</span><span class=\"token operator\">:</span> DebuggerEventExtraInfo</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取所有effect</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> effect <span class=\"token keyword\">of</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> dep <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>dep<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果触发关联的effect 是当前正在执行的，并且没有声明允许递归则不在重复执行 </span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effect <span class=\"token operator\">!==</span> activeEffect <span class=\"token operator\">||</span> effect<span class=\"token punctuation\">.</span>allowRecurse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 触发onTrigger钩子</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__ <span class=\"token operator\">&amp;&amp;</span> effect<span class=\"token punctuation\">.</span>onTrigger<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        effect<span class=\"token punctuation\">.</span><span class=\"token function\">onTrigger</span><span class=\"token punctuation\">(</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> effect <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> debuggerEventExtraInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 如果当前effect有注册调度器，则使用调度器，否则则执行effect注册的函数</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effect<span class=\"token punctuation\">.</span>scheduler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        effect<span class=\"token punctuation\">.</span><span class=\"token function\">scheduler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        effect<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>&emsp;&emsp;<code>triggerEffects</code>传入参数允<code>Array</code>或<code>Dep</code>，会对所有的<code>effect</code>做一次遍历，逐一执行触发钩子、监听函数，大家注意到如果用户自定义了调度器<code>scheduler</code>的话是执行<code>scheduler</code>并不会直接执行监听函数。</p>\n<p>&emsp;&emsp;当前<code>effect</code>是当前正在执行监听函数的<code>effect</code>时会有三种特殊情况：</p>\n<ul>\n<li><code>allowRecurse</code>为<code>false</code>则直接跳过</li>\n<li><code>allowRecurse</code>为<code>true</code>没有自定义调度器时，将执行收集钩子和收集函数，但是执行监听函数前会判断当前<code>effect</code>是否在执行栈中，如果是直接跳过，所以这里只是执行了收集钩子，监听函数并没有允许递归</li>\n<li><code>allowRecurse</code>为<code>true</code>有自定义调度器时，将执行钩子和自定义调度器，允许递归有效。</li>\n</ul>\n<p>&emsp;&emsp;<code>allowRecurse</code>对于监听函数并没有实质作用，即使声明了也不会允许递归，它是作用于<code>scheduler</code>的。</p>\n<h2 id=\"小结\">小结</h2>\n<ul>\n<li><strong><code>effect</code>执行收集函数时不会触发自身</strong></li>\n<li><strong><code>effect</code>函数返回的是收集方法，可以显示调用</strong></li>\n<li><strong><code>effect</code>函数可以传递<code>effect</code>函数返回的方法，会重新包装，但是源绑定方法是一致的</strong></li>\n<li><strong><code>effect</code>监听函数中可以再调用其他收集函数，被调用者不会收集到当前<code>effect</code>的依赖</strong></li>\n<li><strong>对于已经停止观察的<code>effect</code>可以在外层套一层<code>effect</code>继续监听</strong></li>\n<li><strong><code>effect</code>可选参数<code>{ lazy: 懒加载, scheduler: 调度器, scope: .., allowRecurse: 是否允许递归 , onStop: 停止调度钩子, onTrack: 收集时钩子, onTragger: 触发时钩子 }</code></strong></li>\n<li><strong><code>allowRecurse</code>参数是针对<code>scheduler</code>的</strong></li>\n<li><strong><code>vue</code>通过<code>targetMap</code>将<code>effect</code>和收集的<code>target</code>和<code>key</code>建立关系。</strong></li>\n<li><strong><code>key</code>通过<code>Dep</code>与<code>effect</code>建立关系，<code>effect</code>通过缓存<code>deps</code>与<code>key</code>建立关系</strong></li>\n<li><strong><code>effect</code>的<code>deps</code>管理方式有两种，<code>effect</code>层叠数少于30时通过<code>w</code>、<code>n</code>状态细粒增删，超过<code>30</code>则进入前删，后续都是增</strong></li>\n</ul>\n<p>上一章：<a href=\"https://bill-lai.github.io/article/6452d43210bfdd32fd3c/\">vue3-reactive源码解析</a><br>下一章：<a href=\"https://bill-lai.github.io/article/37495e00ab36e870f8dd/\">vue3-ref源码解析</a></p>\n","desc":"阅读准备\n\n本文使用的vue版本为3.2.26。在阅读 effect 源码之前，我们需要知道它的特性，可以通过阅读单例测试源码或者是阅读官网的 API了解特性，推荐阅读单例，了解特性在后面阅读时才能更好理解。\n\n  通过上一章vue3-reactive源码解析，可以猜想到，effect主要职责是存储"}}</script><script>!function(e){function t(t){for(var n,o,i=t[0],c=t[1],l=t[2],s=0,p=[];s<i.length;s++)o=i[s],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&p.push(a[o][0]),a[o]=0;for(n in c)Object.prototype.hasOwnProperty.call(c,n)&&(e[n]=c[n]);for(f&&f(t);p.length;)p.shift()();return u.push.apply(u,l||[]),r()}function r(){for(var e,t=0;t<u.length;t++){for(var r=u[t],n=!0,o=1;o<r.length;o++){var c=r[o];0!==a[c]&&(n=!1)}n&&(u.splice(t--,1),e=i(i.s=r[0]))}return e}var n={},o={1:0},a={1:0},u=[];function i(t){if(n[t])return n[t].exports;var r=n[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.e=function(e){var t=[];o[e]?t.push(o[e]):0!==o[e]&&{4:1}[e]&&t.push(o[e]=new Promise((function(t,r){for(var n="static/css/"+({}[e]||e)+"."+{3:"31d6cfe0",4:"4422e775"}[e]+".chunk.css",a=i.p+n,u=document.getElementsByTagName("link"),c=0;c<u.length;c++){var l=(f=u[c]).getAttribute("data-href")||f.getAttribute("href");if("stylesheet"===f.rel&&(l===n||l===a))return t()}var s=document.getElementsByTagName("style");for(c=0;c<s.length;c++){var f;if((l=(f=s[c]).getAttribute("data-href"))===n||l===a)return t()}var p=document.createElement("link");p.rel="stylesheet",p.type="text/css",p.onload=t,p.onerror=function(t){var n=t&&t.target&&t.target.src||a,u=new Error("Loading CSS chunk "+e+" failed.\n("+n+")");u.code="CSS_CHUNK_LOAD_FAILED",u.request=n,delete o[e],p.parentNode.removeChild(p),r(u)},p.href=a,document.getElementsByTagName("head")[0].appendChild(p)})).then((function(){o[e]=0})));var r=a[e];if(0!==r)if(r)t.push(r[2]);else{var n=new Promise((function(t,n){r=a[e]=[t,n]}));t.push(r[2]=n);var u,c=document.createElement("script");c.charset="utf-8",c.timeout=120,i.nc&&c.setAttribute("nonce",i.nc),c.src=function(e){return i.p+"static/js/"+({}[e]||e)+"."+{3:"c6f781a0",4:"23b5959c"}[e]+".chunk.js"}(e);var l=new Error;u=function(t){c.onerror=c.onload=null,clearTimeout(s);var r=a[e];if(0!==r){if(r){var n=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;l.message="Loading chunk "+e+" failed.\n("+n+": "+o+")",l.name="ChunkLoadError",l.type=n,l.request=o,r[1](l)}a[e]=void 0}};var s=setTimeout((function(){u({type:"timeout",target:c})}),12e4);c.onerror=c.onload=u,document.head.appendChild(c)}return Promise.all(t)},i.m=e,i.c=n,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/",i.oe=function(e){throw console.error(e),e};var c=this.webpackJsonpsource=this.webpackJsonpsource||[],l=c.push.bind(c);c.push=t,c=c.slice();for(var s=0;s<c.length;s++)t(c[s]);var f=l;r()}([])</script><script src="/static/js/2.270a2097.chunk.js"></script><script src="/static/js/main.ff6b76f2.chunk.js"></script></body></html>