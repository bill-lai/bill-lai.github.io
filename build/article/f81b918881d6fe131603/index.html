<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="theme-color" content="#000000"/><link rel="icon" href="/static/images/favicon.ico"/><link rel="apple-touch-icon" href="/static/images/logo192.png"/><link rel="stylesheet" href="/static/lib/simplemde.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-0L4WRG1D3N"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-0L4WRG1D3N")</script><title>跨站请求如何携带凭证 | bill-lai 的博客</title><link href="/static/css/main.8f23dd88.chunk.css" rel="stylesheet"></head><body><input placeholder=""><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="style_app__1yczT"><header class="style_slide__z5PNT style_slide__3Yi3e"><a href="/"><img src="/static/media/portrait.df7a5375.jpg" class="style_portrait__2GrBh" alt="portrait"/></a><div class="style_content__3GlZB"><div class="style_introduce__2UxnL"><h1><a href="/">bill-lai</a></h1><p>专注 WEB 端开发</p></div><ul class="style_navs__2yN9I"><li><a href="/">首页</a></li><li><a href="/archive">专题</a></li><li><a href="/special">归档</a></li></ul></div></header><div class="style_body__3Yz5T"><div class="style_layer__1ZQZt"><div class="style_main__XnHDF"><div> <h1 class="main-title">跨站请求如何携带凭证<span class="marker">2022-04-01 11:35</span></h1><div class="marked-body"><div><h2 id="站请求怎么成功">站请求怎么成功</h2>
<p>跨站请求需要服务端同意，在指定请求响应头中设置<code>Access-Control-Allow-Origin</code>指定该响应允许被哪些域共享。</p>
<pre><code class="language-shell">Access-Control-Allow-Origin: *
Access-Control-Allow-Origin: <span class="token operator">&lt;</span>origin<span class="token operator">></span>
</code></pre>
<p>将<code>Access-Control-Allow-Origin</code>设置为我们的域名之后即可成功访问。</p>
<h2 id="如何携带凭据">如何携带凭据</h2>
<p>通过<code>Access-Control-Allow-Origin</code>可以成功跨站访问，但是我们通过<code>debug</code>会发现，请求没有携带<code>cookie</code>，这是因为我们没有在请求中指示是否要使用<code>cookie、authorization、headers</code>或者<code>TLS</code>客户端证书等凭据来创建跨站点访问。可以通过请求的<code>withCredentials</code>属性来开启它。</p>
<pre><code class="language-js"><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHtppRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token property-access">withCredentials</span> <span class="token operator">=</span> <span class="token boolean">true</span>
xhr<span class="token punctuation">.</span><span class="token method function property-access">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'http://example.com'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token method function property-access">send</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span>
</code></pre>
<p>我们再刷新请求会发现请求直接报错了，这是因为我们请求指示要求服务器允许使用凭据，但是服务器响应并没有指示允许。这时候还要在响应头中设置<code>Access-Control-Allow-Credentials</code>为<code>true</code>来明确允许。除此之外<code>Access-Control-Allow-Origin</code>不能是通配符比如<code>*</code>，而是必须是明确的值，就是必须明确允许请求的域</p>
<pre><code class="language-shell">Access-Control-Allow-Credentials: <span class="token boolean">true</span>
Access-Control-Allow-Origin: <span class="token operator">&lt;</span>origin<span class="token operator">></span>
</code></pre>
<p>在旧版的浏览器中，基于上方的配置就能成功在请求中携带<code>cookie</code>了。</p>
<h2 id="新版本，安全性升级">新版本，安全性升级</h2>
<p>我们基于上方配置在<code>chrome51</code>之后的浏览器访问会发现依旧没有携带上<code>cookie</code>访问，这是因为在<code>chrome51</code>之后浏览器对<code>cookie</code>新增了一个会影响跨站携带凭证的属性 <strong>SameSite</strong>，下面是这个属性的值：</p>
<ul>
<li><code>Strict</code>，严格的，完全禁止第三方<code>cookie</code>，只有当前网页URL与请求目标一致才会携带。可能造成不好的用户体验，比如从一个<code>github</code>连接点击进去不会携带<code>cookie</code>会被判断为未登录</li>
<li><code>Lax</code>，稍微宽松，大多数不允许第三方<code>cookie</code>，从导航到目标地址的<code>Get</code> <em>（链接，预加载请求，GET表单）</em> 除外。</li>
<li><code>None</code>允许第三方跨站访问携带<code>cookie</code>，该属性有一个要求，必须同时为<code>cookie</code>设置<code>Secure</code> _（该值指明cookie只能在https请求中被携带）_，第三方必须是<code>https</code>协议的源。</li>
</ul>
<p>所以除了对新版本中响应的<code>cookie</code>设置为<code>SameSite=None; Secure</code>外，请求放必须是<code>https</code>站点。</p>
<pre><code class="language-shell">Set-Cookie: xxx<span class="token punctuation">;</span> <span class="token assign-left variable">SameSite</span><span class="token operator">=</span>None<span class="token punctuation">;</span> Secure
</code></pre>
<h2 id="相关阅读">相关阅读</h2>
<ul>
<li><a href="https://bill-lai.github.io/article/d127138063d45832d5b7">前后端常见网络安全问题及防范措施</a></li>
<li><a href="https://bill-lai.github.io/article/2b99b3a4b5641cca38d3">iframe,ajax,canvas跨域处理</a></li>
</ul>
</div></div><div class="style_article-loading-layer__3poja"><div class="style_layer__GxMiF"><div style="fill:var(--vice-color);height:64px;width:64px"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle transform="translate(8 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(16 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.3"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
  <circle transform="translate(24 0)" cx="0" cy="16" r="0"> 
    <animate attributeName="r" values="0; 4; 0; 0" dur="1.2s" repeatCount="indefinite" begin="0.6"
      keytimes="0;0.2;0.7;1" keySplines="0.2 0.2 0.4 0.8;0.2 0.6 0.4 0.8;0.2 0.6 0.4 0.8" calcMode="spline" />
  </circle>
</svg>
</div></div></div> </div><div class="style_bottom__29qYA"><p>©2021 - bill-lai 的小站 -<a rel="noreferrer" href="https://github.com/bill-lai/bill-lai.github.io" target="_blank">站点源码</a></p><p>本站使用<a rel="noreferrer" target="_blank" href="https://react.docschina.org/docs/hooks-reference.html#usememo">ReactHook</a><a rel="noreferrer" target="_blank" href="https://www.typescriptlang.org/zh/">TypeScript</a><a rel="noreferrer" target="_blank" href="https://docs.github.com/cn/rest">githubAPI</a><a rel="noreferrer" target="_blank" href="https://simplemde.com/">SimpleMDE</a>制作</p></div></div><div class="style_right-layer__Rm9TS "><div class="style_right__3hdcL"><div class="style_right-content__F68mu"><div class="navigation"><h4 class="style_title__1aA1F">目录列表</h4><ul class="style_top-navs__3vyAr"><li class=""><span>站请求怎么成功<!-- --> </span></li><li class=""><span>如何携带凭据<!-- --> </span></li><li class=""><span>新版本，安全性升级<!-- --> </span></li><li class=""><span>相关阅读<!-- --> </span></li></ul></div></div></div></div></div></div></div></div>
        <script>var globalState = {"article/f81b918881d6fe131603":{"title":"跨站请求如何携带凭证","id":"f81b918881d6fe131603","mtime":1648784155625,"ctime":1648780533657,"issues":{"number":31,"commentsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/31/comments","reactionsUrl":"https://api.github.com/repos/bill-lai/bill-lai.github.io/issues/31/reactions"},"head":null,"foot":null,"dirs":[{"leave":2,"title":"站请求怎么成功","children":[]},{"leave":2,"title":"如何携带凭据","children":[]},{"leave":2,"title":"新版本，安全性升级","children":[]},{"leave":2,"title":"相关阅读","children":[]}],"body":"<h2 id=\"站请求怎么成功\">站请求怎么成功</h2>\n<p>跨站请求需要服务端同意，在指定请求响应头中设置<code>Access-Control-Allow-Origin</code>指定该响应允许被哪些域共享。</p>\n<pre><code class=\"language-shell\">Access-Control-Allow-Origin: *\nAccess-Control-Allow-Origin: <span class=\"token operator\">&lt;</span>origin<span class=\"token operator\">></span>\n</code></pre>\n<p>将<code>Access-Control-Allow-Origin</code>设置为我们的域名之后即可成功访问。</p>\n<h2 id=\"如何携带凭据\">如何携带凭据</h2>\n<p>通过<code>Access-Control-Allow-Origin</code>可以成功跨站访问，但是我们通过<code>debug</code>会发现，请求没有携带<code>cookie</code>，这是因为我们没有在请求中指示是否要使用<code>cookie、authorization、headers</code>或者<code>TLS</code>客户端证书等凭据来创建跨站点访问。可以通过请求的<code>withCredentials</code>属性来开启它。</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHtppRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token property-access\">withCredentials</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://example.com'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword null nil\">null</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>我们再刷新请求会发现请求直接报错了，这是因为我们请求指示要求服务器允许使用凭据，但是服务器响应并没有指示允许。这时候还要在响应头中设置<code>Access-Control-Allow-Credentials</code>为<code>true</code>来明确允许。除此之外<code>Access-Control-Allow-Origin</code>不能是通配符比如<code>*</code>，而是必须是明确的值，就是必须明确允许请求的域</p>\n<pre><code class=\"language-shell\">Access-Control-Allow-Credentials: <span class=\"token boolean\">true</span>\nAccess-Control-Allow-Origin: <span class=\"token operator\">&lt;</span>origin<span class=\"token operator\">></span>\n</code></pre>\n<p>在旧版的浏览器中，基于上方的配置就能成功在请求中携带<code>cookie</code>了。</p>\n<h2 id=\"新版本，安全性升级\">新版本，安全性升级</h2>\n<p>我们基于上方配置在<code>chrome51</code>之后的浏览器访问会发现依旧没有携带上<code>cookie</code>访问，这是因为在<code>chrome51</code>之后浏览器对<code>cookie</code>新增了一个会影响跨站携带凭证的属性 <strong>SameSite</strong>，下面是这个属性的值：</p>\n<ul>\n<li><code>Strict</code>，严格的，完全禁止第三方<code>cookie</code>，只有当前网页URL与请求目标一致才会携带。可能造成不好的用户体验，比如从一个<code>github</code>连接点击进去不会携带<code>cookie</code>会被判断为未登录</li>\n<li><code>Lax</code>，稍微宽松，大多数不允许第三方<code>cookie</code>，从导航到目标地址的<code>Get</code> <em>（链接，预加载请求，GET表单）</em> 除外。</li>\n<li><code>None</code>允许第三方跨站访问携带<code>cookie</code>，该属性有一个要求，必须同时为<code>cookie</code>设置<code>Secure</code> _（该值指明cookie只能在https请求中被携带）_，第三方必须是<code>https</code>协议的源。</li>\n</ul>\n<p>所以除了对新版本中响应的<code>cookie</code>设置为<code>SameSite=None; Secure</code>外，请求放必须是<code>https</code>站点。</p>\n<pre><code class=\"language-shell\">Set-Cookie: xxx<span class=\"token punctuation\">;</span> <span class=\"token assign-left variable\">SameSite</span><span class=\"token operator\">=</span>None<span class=\"token punctuation\">;</span> Secure\n</code></pre>\n<h2 id=\"相关阅读\">相关阅读</h2>\n<ul>\n<li><a href=\"https://bill-lai.github.io/article/d127138063d45832d5b7\">前后端常见网络安全问题及防范措施</a></li>\n<li><a href=\"https://bill-lai.github.io/article/2b99b3a4b5641cca38d3\">iframe,ajax,canvas跨域处理</a></li>\n</ul>\n","desc":"站请求怎么成功\n跨站请求需要服务端同意，在指定请求响应头中设置Access-Control-Allow-Origin指定该响应允许被哪些域共享。\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Origin: <origin>\n\n将Access"}}</script><script>!function(e){function t(t){for(var n,o,i=t[0],c=t[1],l=t[2],s=0,p=[];s<i.length;s++)o=i[s],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&p.push(a[o][0]),a[o]=0;for(n in c)Object.prototype.hasOwnProperty.call(c,n)&&(e[n]=c[n]);for(f&&f(t);p.length;)p.shift()();return u.push.apply(u,l||[]),r()}function r(){for(var e,t=0;t<u.length;t++){for(var r=u[t],n=!0,o=1;o<r.length;o++){var c=r[o];0!==a[c]&&(n=!1)}n&&(u.splice(t--,1),e=i(i.s=r[0]))}return e}var n={},o={1:0},a={1:0},u=[];function i(t){if(n[t])return n[t].exports;var r=n[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.e=function(e){var t=[];o[e]?t.push(o[e]):0!==o[e]&&{4:1}[e]&&t.push(o[e]=new Promise((function(t,r){for(var n="static/css/"+({}[e]||e)+"."+{3:"31d6cfe0",4:"4422e775"}[e]+".chunk.css",a=i.p+n,u=document.getElementsByTagName("link"),c=0;c<u.length;c++){var l=(f=u[c]).getAttribute("data-href")||f.getAttribute("href");if("stylesheet"===f.rel&&(l===n||l===a))return t()}var s=document.getElementsByTagName("style");for(c=0;c<s.length;c++){var f;if((l=(f=s[c]).getAttribute("data-href"))===n||l===a)return t()}var p=document.createElement("link");p.rel="stylesheet",p.type="text/css",p.onload=t,p.onerror=function(t){var n=t&&t.target&&t.target.src||a,u=new Error("Loading CSS chunk "+e+" failed.\n("+n+")");u.code="CSS_CHUNK_LOAD_FAILED",u.request=n,delete o[e],p.parentNode.removeChild(p),r(u)},p.href=a,document.getElementsByTagName("head")[0].appendChild(p)})).then((function(){o[e]=0})));var r=a[e];if(0!==r)if(r)t.push(r[2]);else{var n=new Promise((function(t,n){r=a[e]=[t,n]}));t.push(r[2]=n);var u,c=document.createElement("script");c.charset="utf-8",c.timeout=120,i.nc&&c.setAttribute("nonce",i.nc),c.src=function(e){return i.p+"static/js/"+({}[e]||e)+"."+{3:"c6f781a0",4:"199baeb9"}[e]+".chunk.js"}(e);var l=new Error;u=function(t){c.onerror=c.onload=null,clearTimeout(s);var r=a[e];if(0!==r){if(r){var n=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;l.message="Loading chunk "+e+" failed.\n("+n+": "+o+")",l.name="ChunkLoadError",l.type=n,l.request=o,r[1](l)}a[e]=void 0}};var s=setTimeout((function(){u({type:"timeout",target:c})}),12e4);c.onerror=c.onload=u,document.head.appendChild(c)}return Promise.all(t)},i.m=e,i.c=n,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/",i.oe=function(e){throw console.error(e),e};var c=this.webpackJsonpsource=this.webpackJsonpsource||[],l=c.push.bind(c);c.push=t,c=c.slice();for(var s=0;s<c.length;s++)t(c[s]);var f=l;r()}([])</script><script src="/static/js/2.b25e0f2c.chunk.js"></script><script src="/static/js/main.18e76180.chunk.js"></script></body></html>